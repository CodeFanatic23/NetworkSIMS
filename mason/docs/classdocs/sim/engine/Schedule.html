<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!-- NewPage -->
<html lang="en">
<head>
<!-- Generated by javadoc (version 1.7.0_51) on Fri Jun 19 12:12:00 EDT 2015 -->
<title>Schedule</title>
<meta name="date" content="2015-06-19">
<link rel="stylesheet" type="text/css" href="../../stylesheet.css" title="Style">
</head>
<body>
<script type="text/javascript"><!--
    if (location.href.indexOf('is-external=true') == -1) {
        parent.document.title="Schedule";
    }
//-->
</script>
<noscript>
<div>JavaScript is disabled on your browser.</div>
</noscript>
<!-- ========= START OF TOP NAVBAR ======= -->
<div class="topNav"><a name="navbar_top">
<!--   -->
</a><a href="#skip-navbar_top" title="Skip navigation links"></a><a name="navbar_top_firstrow">
<!--   -->
</a>
<ul class="navList" title="Navigation">
<li><a href="../../overview-summary.html">Overview</a></li>
<li><a href="package-summary.html">Package</a></li>
<li class="navBarCell1Rev">Class</li>
<li><a href="package-tree.html">Tree</a></li>
<li><a href="../../deprecated-list.html">Deprecated</a></li>
<li><a href="../../index-all.html">Index</a></li>
<li><a href="../../help-doc.html">Help</a></li>
</ul>
</div>
<div class="subNav">
<ul class="navList">
<li><a href="../../sim/engine/Repeat.html" title="class in sim.engine"><span class="strong">Prev Class</span></a></li>
<li><a href="../../sim/engine/Schedule.Key.html" title="class in sim.engine"><span class="strong">Next Class</span></a></li>
</ul>
<ul class="navList">
<li><a href="../../index.html?sim/engine/Schedule.html" target="_top">Frames</a></li>
<li><a href="Schedule.html" target="_top">No Frames</a></li>
</ul>
<ul class="navList" id="allclasses_navbar_top">
<li><a href="../../allclasses-noframe.html">All Classes</a></li>
</ul>
<div>
<script type="text/javascript"><!--
  allClassesLink = document.getElementById("allclasses_navbar_top");
  if(window==top) {
    allClassesLink.style.display = "block";
  }
  else {
    allClassesLink.style.display = "none";
  }
  //-->
</script>
</div>
<div>
<ul class="subNavList">
<li>Summary:&nbsp;</li>
<li><a href="#nested_class_summary">Nested</a>&nbsp;|&nbsp;</li>
<li><a href="#field_summary">Field</a>&nbsp;|&nbsp;</li>
<li><a href="#constructor_summary">Constr</a>&nbsp;|&nbsp;</li>
<li><a href="#method_summary">Method</a></li>
</ul>
<ul class="subNavList">
<li>Detail:&nbsp;</li>
<li><a href="#field_detail">Field</a>&nbsp;|&nbsp;</li>
<li><a href="#constructor_detail">Constr</a>&nbsp;|&nbsp;</li>
<li><a href="#method_detail">Method</a></li>
</ul>
</div>
<a name="skip-navbar_top">
<!--   -->
</a></div>
<!-- ========= END OF TOP NAVBAR ========= -->
<!-- ======== START OF CLASS DATA ======== -->
<div class="header">
<div class="subTitle">sim.engine</div>
<h2 title="Class Schedule" class="title">Class Schedule</h2>
</div>
<div class="contentContainer">
<ul class="inheritance">
<li>java.lang.Object</li>
<li>
<ul class="inheritance">
<li>sim.engine.Schedule</li>
</ul>
</li>
</ul>
<div class="description">
<ul class="blockList">
<li class="blockList">
<dl>
<dt>All Implemented Interfaces:</dt>
<dd>java.io.Serializable</dd>
</dl>
<hr>
<br>
<pre>public class <span class="strong">Schedule</span>
extends java.lang.Object
implements java.io.Serializable</pre>
<div class="block">Schedule defines a threadsafe scheduling queue in which events can be scheduled to occur
   at future time.  The time of the most recent event which has already occured
   is given by the <b>getTime()</b> method.  If the current time is <tt>BEFORE_SIMULATION</tt> (defined
   to be <tt>EPOCH - 1</tt>),
   then the schedule is set to the "time before time" (the schedule hasn't started running
   yet).  If the current time is <tt>AFTER_SIMULATION</tt> (positive infinity), then the schedule has run
   out of time.  <tt>EPOCH</tt> (0.0) is defined as the first timestep for which you can legally schedule a value.
   <tt>EPOCH_PLUS_ESPILON</tt> is defined as the smallest possible second timestep for which you can legally sechedule a value.
   If you're scheduling events to occur on integer timesteps, you may want to ensure that your simulation 
   does not run beyond <tt>MAXIMUM_INTEGER</tt> (9007199254740992L or 9.007199254740992E15).  For values of a 
   double d >= <tt>MAXIMUM_INTEGER</tt>, d + 1 == d !

   <p>An event is defined as a <b>Steppable</b> object. You can schedule events to either 
   occur a single time or to occur repeatedly at some interval.  If the event occurs repeatedly,
   the schedule will provide you with a <b>Stoppable</b> object on which you can call <b>stop()</b>
   to cancel all future repeats of the event.  If instead you wish to "stop" a single-time event from occuring
   before its time has come, you should do so through the use of a <b>TentativeStep</b> object.  At present
   you cannot delete objects from the Schedule -- just stop them and let them drop out in due course.

   <p>The schedule is pulsed by calling its <b>step(...)</b> method.  Each pulse, the schedule
   finds the minimum time at which events are scheduled, moves ahead to that time, and then calls
   all the events scheduled at that time.    Multiple events may be scheduled for the same time.
   No event may be scheduled for a time earlier than getTime().  If at time getTime() you schedule a new
   event for time getTime(), then actually this event will occur at time getTime()+epsilon, that is, the
   smallest possible slice of time greater than getTime().

   <p><b>IMPORTANT NOTE:</b> we have disabled the setShuffling() procedure by making the methods private.  The reason for this is that although turning off shuffling causes the Steppables to be stepped in a <i>predictable order</i>, they will not necessarily be stepped in <i>the order in which they were submitted</i>, which was the whole point of the methods.  The reason for this is that a binary heap is not "stable": it doesn't break ties by returning elements in the same order in which they appeared.  This potentially could cause bugs in simulations and we want to make it very clear.

   <p>Events at a step are further subdivided and scheduled according to their <i>ordering</i>, an integer.
   Objects for scheduled for lower orderings for a given time will be executed before objects with
   higher orderings for the same time.  If objects are scheduled for the same time and
   have the same ordering value, their execution will be randomly ordered with respect to one another.

   <!-- 
   unless (in the very rare case) you have called setShuffling(false);.  Generally speaking, most experiments with
   good model methodologies will want random shuffling left on, and if you need an explicit ordering, it may be
   better to rely on Steppable's orderings or to use a Sequence.
   -->

   <p>You might be wondering: why bother with using orderings?  After all, can't you achieve the same thing by just
   stretching elements out in time?  There are two reasons to use orderings.  First, it allows you to use the getTime()
   method to keep tabs on the current time in a way that might be convenient to you.  But second and more importantly,
   MASON's GUI facility will update its displays and inspectors only after all Steppables scheduled for a 
   given timestamp have completed, and so orderings give you a way of subdividing the interval of time between
   GUI updates.

   <p>A schedule may be <i>sealed</i> meaning that it will refuse to accept any further scheduled events
   even if its time is not yet AFTER_SIMULATION.  This is largely done internally by MASON code: you probably
   will never want to do this.  Once a schedule is sealed it cannot be unsealed until it is reset().

   <p>You can clear out the entire Schedule, unseal it, and restart it to BEFORE_SIMULATION by calling reset().
   However, this does not prevent AsynchronousSteppables from suddenly rescheduling themselves
   in the queue.  Stopping the simulation from within a Steppable object's step() method is best done by
   calling SimState.kill().  From the main thread, the most straightforward way to stop a simulation is to just
   stop calling schedule.step(...), and proceed directly to SimState.finish().

   <p>You can get the number of times that step(...) has been called on the schedule by calling the getSteps() method.
   This value is incremented just as the Schedule exits its step(...) method and only if the method returned true.
   Additionally, you can get a string version of the current time with the getTimestamp(...) method.

   <p><b>Note on Synchronization</b>.  In order to maximize the ability for threads to access the Schedule at any time, 
   Schedule uses two locks for synchronization.  First, the <b>step() method synchronizes on the Schedule</b> itself.  This
   prevents step() from being called simultaneously from different threads; also step() tests to make sure that it's not
   called reentrantly from within the same thread.  Second, <b>many methods synchronize on an internal lock</b>, including step().
   This allows step() to synchronize on the lock only to suck out the relevant Steppables from the Heap and to advance the timestep;
   all other portions of step() are outside of the lock.  Thus when step() actually steps the Steppables, even in different threads
   (like AsynchronousSteppable or ParallelSequence), they can turn around and submit step-requests to the Schedule even while it's still
   in its step() method.

   <p>One downside to this flexibility is that it's very inefficient to check, at each step of a Steppable, whether the Schedule
   has been reset or not.  Thus now if you call reset() or [better] SimState.kill(), the Schedule will continue to step Steppables
   until it has exhausted ones scheduled for the current timestep.  Only at that point will it cease.

   <p><b>Heaps and Calendar Queues</b>.  Schedule uses a plain-old binary heap for its queueing mechanism.  This is reasonably efficient,
   but it could be made more efficient with a Calendar Queue designed for the purposes of your simulation.  We settled on a Heap because
   we do not know what the expected scheduling pattern will be for any given simulation, and so had to go for the most general case.  If you'd
   care to customize your queue, you can do so by overriding the createHeap() method in a custom Schedule.  We imagine this would be rare.</div>
<dl><dt><span class="strong">See Also:</span></dt><dd><a href="../../serialized-form.html#sim.engine.Schedule">Serialized Form</a></dd></dl>
</li>
</ul>
</div>
<div class="summary">
<ul class="blockList">
<li class="blockList">
<!-- ======== NESTED CLASS SUMMARY ======== -->
<ul class="blockList">
<li class="blockList"><a name="nested_class_summary">
<!--   -->
</a>
<h3>Nested Class Summary</h3>
<table class="overviewSummary" border="0" cellpadding="3" cellspacing="0" summary="Nested Class Summary table, listing nested classes, and an explanation">
<caption><span>Nested Classes</span><span class="tabEnd">&nbsp;</span></caption>
<tr>
<th class="colFirst" scope="col">Modifier and Type</th>
<th class="colLast" scope="col">Class and Description</th>
</tr>
<tr class="altColor">
<td class="colFirst"><code>protected static class&nbsp;</code></td>
<td class="colLast"><code><strong><a href="../../sim/engine/Schedule.Key.html" title="class in sim.engine">Schedule.Key</a></strong></code>
<div class="block">Timestamps stored as keys in the heap.</div>
</td>
</tr>
</table>
</li>
</ul>
<!-- =========== FIELD SUMMARY =========== -->
<ul class="blockList">
<li class="blockList"><a name="field_summary">
<!--   -->
</a>
<h3>Field Summary</h3>
<table class="overviewSummary" border="0" cellpadding="3" cellspacing="0" summary="Field Summary table, listing fields, and an explanation">
<caption><span>Fields</span><span class="tabEnd">&nbsp;</span></caption>
<tr>
<th class="colFirst" scope="col">Modifier and Type</th>
<th class="colLast" scope="col">Field and Description</th>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static double</code></td>
<td class="colLast"><code><strong><a href="../../sim/engine/Schedule.html#AFTER_SIMULATION">AFTER_SIMULATION</a></strong></code>
<div class="block">The time which indicates that the Schedule is finished.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static double</code></td>
<td class="colLast"><code><strong><a href="../../sim/engine/Schedule.html#BEFORE_SIMULATION">BEFORE_SIMULATION</a></strong></code>
<div class="block">The time which indicates that the Schedule hasn't started yet.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static double</code></td>
<td class="colLast"><code><strong><a href="../../sim/engine/Schedule.html#EPOCH">EPOCH</a></strong></code>
<div class="block">The first possible schedulable time.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static double</code></td>
<td class="colLast"><code><strong><a href="../../sim/engine/Schedule.html#EPOCH_PLUS_EPSILON">EPOCH_PLUS_EPSILON</a></strong></code>
<div class="block">The second possible schedulable time.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>protected java.lang.Object</code></td>
<td class="colLast"><code><strong><a href="../../sim/engine/Schedule.html#lock">lock</a></strong></code>
<div class="block">The schedule lock.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static double</code></td>
<td class="colLast"><code><strong><a href="../../sim/engine/Schedule.html#MAXIMUM_INTEGER">MAXIMUM_INTEGER</a></strong></code>
<div class="block">The last time beyond which the schedule is no longer able to precisely maintain integer values due to loss of precision.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>protected <a href="../../sim/util/Heap.html" title="class in sim.util">Heap</a></code></td>
<td class="colLast"><code><strong><a href="../../sim/engine/Schedule.html#queue">queue</a></strong></code>
<div class="block">The Schedule's queue.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>protected boolean</code></td>
<td class="colLast"><code><strong><a href="../../sim/engine/Schedule.html#sealed">sealed</a></strong></code>
<div class="block">Whether the schedule is sealed, as returned by isSealed().</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>protected long</code></td>
<td class="colLast"><code><strong><a href="../../sim/engine/Schedule.html#steps">steps</a></strong></code>
<div class="block">The current steps, as returned by getSteps().</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>protected double</code></td>
<td class="colLast"><code><strong><a href="../../sim/engine/Schedule.html#time">time</a></strong></code>
<div class="block">The current time, as returned by getTime().</div>
</td>
</tr>
</table>
</li>
</ul>
<!-- ======== CONSTRUCTOR SUMMARY ======== -->
<ul class="blockList">
<li class="blockList"><a name="constructor_summary">
<!--   -->
</a>
<h3>Constructor Summary</h3>
<table class="overviewSummary" border="0" cellpadding="3" cellspacing="0" summary="Constructor Summary table, listing constructors, and an explanation">
<caption><span>Constructors</span><span class="tabEnd">&nbsp;</span></caption>
<tr>
<th class="colOne" scope="col">Constructor and Description</th>
</tr>
<tr class="altColor">
<td class="colOne"><code><strong><a href="../../sim/engine/Schedule.html#Schedule()">Schedule</a></strong>()</code>
<div class="block">Creates a Schedule.</div>
</td>
</tr>
</table>
</li>
</ul>
<!-- ========== METHOD SUMMARY =========== -->
<ul class="blockList">
<li class="blockList"><a name="method_summary">
<!--   -->
</a>
<h3>Method Summary</h3>
<table class="overviewSummary" border="0" cellpadding="3" cellspacing="0" summary="Method Summary table, listing methods, and an explanation">
<caption><span>Methods</span><span class="tabEnd">&nbsp;</span></caption>
<tr>
<th class="colFirst" scope="col">Modifier and Type</th>
<th class="colLast" scope="col">Method and Description</th>
</tr>
<tr class="altColor">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><strong><a href="../../sim/engine/Schedule.html#clear()">clear</a></strong>()</code>
<div class="block">Empties out the schedule but does not reset the time or steps.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>protected <a href="../../sim/util/Heap.html" title="class in sim.util">Heap</a></code></td>
<td class="colLast"><code><strong><a href="../../sim/engine/Schedule.html#createHeap()">createHeap</a></strong>()</code>
<div class="block">Returns a Heap to be used by the Schedule.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>long</code></td>
<td class="colLast"><code><strong><a href="../../sim/engine/Schedule.html#getSteps()">getSteps</a></strong>()</code>
<div class="block">Returns the number of steps the Schedule has pulsed so far.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>double</code></td>
<td class="colLast"><code><strong><a href="../../sim/engine/Schedule.html#getTime()">getTime</a></strong>()</code>
<div class="block">Returns the current timestep</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>java.lang.String</code></td>
<td class="colLast"><code><strong><a href="../../sim/engine/Schedule.html#getTimestamp(double, java.lang.String, java.lang.String)">getTimestamp</a></strong>(double&nbsp;time,
            java.lang.String&nbsp;beforeSimulationString,
            java.lang.String&nbsp;afterSimulationString)</code>
<div class="block">Returns a given time in string format.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>java.lang.String</code></td>
<td class="colLast"><code><strong><a href="../../sim/engine/Schedule.html#getTimestamp(java.lang.String, java.lang.String)">getTimestamp</a></strong>(java.lang.String&nbsp;beforeSimulationString,
            java.lang.String&nbsp;afterSimulationString)</code>
<div class="block">Returns the current time in string format.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><strong><a href="../../sim/engine/Schedule.html#isSealed()">isSealed</a></strong>()</code>
<div class="block">Returns whether or not the schedule is sealed (nothing more can be scheduled, even 
        if the schedule isn't at AFTER_SIMULATION yet).</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><strong><a href="../../sim/engine/Schedule.html#merge(sim.engine.Schedule)">merge</a></strong>(<a href="../../sim/engine/Schedule.html" title="class in sim.engine">Schedule</a>&nbsp;other)</code>
<div class="block">Merge a given schedule into this one.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><strong><a href="../../sim/engine/Schedule.html#reset()">reset</a></strong>()</code>
<div class="block">Empties out the schedule and resets it to a pristine state BEFORE_SIMULATION, with steps = 0.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><strong><a href="../../sim/engine/Schedule.html#scheduleComplete()">scheduleComplete</a></strong>()</code>
<div class="block">Returns true if the schedule has nothing left to do.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><strong><a href="../../sim/engine/Schedule.html#scheduleOnce(double, int, sim.engine.Steppable)">scheduleOnce</a></strong>(double&nbsp;time,
            int&nbsp;ordering,
            <a href="../../sim/engine/Steppable.html" title="interface in sim.engine">Steppable</a>&nbsp;event)</code>
<div class="block">Schedules the event to occur at the provided time, and in the ordering provided.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><strong><a href="../../sim/engine/Schedule.html#scheduleOnce(double, sim.engine.Steppable)">scheduleOnce</a></strong>(double&nbsp;time,
            <a href="../../sim/engine/Steppable.html" title="interface in sim.engine">Steppable</a>&nbsp;event)</code>
<div class="block">Schedules the event to occur at the provided time, 0 ordering.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>protected boolean</code></td>
<td class="colLast"><code><strong><a href="../../sim/engine/Schedule.html#scheduleOnce(sim.engine.Schedule.Key, sim.engine.Steppable)">scheduleOnce</a></strong>(<a href="../../sim/engine/Schedule.Key.html" title="class in sim.engine">Schedule.Key</a>&nbsp;key,
            <a href="../../sim/engine/Steppable.html" title="interface in sim.engine">Steppable</a>&nbsp;event)</code>
<div class="block">Schedules an item.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><strong><a href="../../sim/engine/Schedule.html#scheduleOnce(sim.engine.Steppable)">scheduleOnce</a></strong>(<a href="../../sim/engine/Steppable.html" title="interface in sim.engine">Steppable</a>&nbsp;event)</code>
<div class="block">Schedules the event to occur at getTime() + 1.0, 0 ordering.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><strong><a href="../../sim/engine/Schedule.html#scheduleOnce(sim.engine.Steppable, int)">scheduleOnce</a></strong>(<a href="../../sim/engine/Steppable.html" title="interface in sim.engine">Steppable</a>&nbsp;event,
            int&nbsp;ordering)</code>
<div class="block">Schedules the event to occur at getTime() + 1.0, and in the ordering provided.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><strong><a href="../../sim/engine/Schedule.html#scheduleOnceIn(double, sim.engine.Steppable)">scheduleOnceIn</a></strong>(double&nbsp;delta,
              <a href="../../sim/engine/Steppable.html" title="interface in sim.engine">Steppable</a>&nbsp;event)</code>
<div class="block">Schedules the event to occur at getTime() + delta, 0 ordering.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><strong><a href="../../sim/engine/Schedule.html#scheduleOnceIn(double, sim.engine.Steppable, int)">scheduleOnceIn</a></strong>(double&nbsp;delta,
              <a href="../../sim/engine/Steppable.html" title="interface in sim.engine">Steppable</a>&nbsp;event,
              int&nbsp;ordering)</code>
<div class="block">Schedules the event to occur at getTime() + delta, and in the ordering provided.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code><a href="../../sim/engine/Stoppable.html" title="interface in sim.engine">Stoppable</a></code></td>
<td class="colLast"><code><strong><a href="../../sim/engine/Schedule.html#scheduleRepeating(double, int, sim.engine.Steppable)">scheduleRepeating</a></strong>(double&nbsp;time,
                 int&nbsp;ordering,
                 <a href="../../sim/engine/Steppable.html" title="interface in sim.engine">Steppable</a>&nbsp;event)</code>
<div class="block">Schedules the event to recur at an interval of 1.0 starting at the provided time, 
        and in the ordering provided.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code><a href="../../sim/engine/Stoppable.html" title="interface in sim.engine">Stoppable</a></code></td>
<td class="colLast"><code><strong><a href="../../sim/engine/Schedule.html#scheduleRepeating(double, int, sim.engine.Steppable, double)">scheduleRepeating</a></strong>(double&nbsp;time,
                 int&nbsp;ordering,
                 <a href="../../sim/engine/Steppable.html" title="interface in sim.engine">Steppable</a>&nbsp;event,
                 double&nbsp;interval)</code>
<div class="block">Schedules the event to recur at the specified interval starting at the provided time, 
        and in the ordering provided.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code><a href="../../sim/engine/Stoppable.html" title="interface in sim.engine">Stoppable</a></code></td>
<td class="colLast"><code><strong><a href="../../sim/engine/Schedule.html#scheduleRepeating(double, sim.engine.Steppable)">scheduleRepeating</a></strong>(double&nbsp;time,
                 <a href="../../sim/engine/Steppable.html" title="interface in sim.engine">Steppable</a>&nbsp;event)</code>
<div class="block">Schedules the event to recur at the specified interval starting at the provided time, and at 0 ordering.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code><a href="../../sim/engine/Stoppable.html" title="interface in sim.engine">Stoppable</a></code></td>
<td class="colLast"><code><strong><a href="../../sim/engine/Schedule.html#scheduleRepeating(double, sim.engine.Steppable, double)">scheduleRepeating</a></strong>(double&nbsp;time,
                 <a href="../../sim/engine/Steppable.html" title="interface in sim.engine">Steppable</a>&nbsp;event,
                 double&nbsp;interval)</code>
<div class="block">Schedules the event to recur at the specified interval starting at the provided time, 
        in ordering 0.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code><a href="../../sim/engine/Stoppable.html" title="interface in sim.engine">Stoppable</a></code></td>
<td class="colLast"><code><strong><a href="../../sim/engine/Schedule.html#scheduleRepeating(sim.engine.Steppable)">scheduleRepeating</a></strong>(<a href="../../sim/engine/Steppable.html" title="interface in sim.engine">Steppable</a>&nbsp;event)</code>
<div class="block">Schedules the event to recur at an interval of 1.0 starting at getTime() + 1.0, and at 0 ordering.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code><a href="../../sim/engine/Stoppable.html" title="interface in sim.engine">Stoppable</a></code></td>
<td class="colLast"><code><strong><a href="../../sim/engine/Schedule.html#scheduleRepeating(sim.engine.Steppable, double)">scheduleRepeating</a></strong>(<a href="../../sim/engine/Steppable.html" title="interface in sim.engine">Steppable</a>&nbsp;event,
                 double&nbsp;interval)</code>
<div class="block">Schedules the event to recur at the specified interval starting at getTime() + interval, and at 0 ordering.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code><a href="../../sim/engine/Stoppable.html" title="interface in sim.engine">Stoppable</a></code></td>
<td class="colLast"><code><strong><a href="../../sim/engine/Schedule.html#scheduleRepeating(sim.engine.Steppable, int, double)">scheduleRepeating</a></strong>(<a href="../../sim/engine/Steppable.html" title="interface in sim.engine">Steppable</a>&nbsp;event,
                 int&nbsp;ordering,
                 double&nbsp;interval)</code>
<div class="block">Schedules the event to recur at the specified interval starting at getTime() + interval, and at the provided ordering.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><strong><a href="../../sim/engine/Schedule.html#seal()">seal</a></strong>()</code>
<div class="block">Seals the schedule: after a schedule is sealed, no further Steppables may be scheduled on it.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><strong><a href="../../sim/engine/Schedule.html#step(sim.engine.SimState)">step</a></strong>(<a href="../../sim/engine/SimState.html" title="class in sim.engine">SimState</a>&nbsp;state)</code>
<div class="block">Steps the schedule, gathering and ordering all the items to step on the next time step (skipping
        blank time steps), and then stepping all of them in the decided order.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>double</code></td>
<td class="colLast"><code><strong><a href="../../sim/engine/Schedule.html#time()">time</a></strong>()</code>
<div class="block"><strong>Deprecated.</strong>&nbsp;
<div class="block"><i>use getTime()</i></div>
</div>
</td>
</tr>
</table>
<ul class="blockList">
<li class="blockList"><a name="methods_inherited_from_class_java.lang.Object">
<!--   -->
</a>
<h3>Methods inherited from class&nbsp;java.lang.Object</h3>
<code>clone, equals, finalize, getClass, hashCode, notify, notifyAll, toString, wait, wait, wait</code></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
<div class="details">
<ul class="blockList">
<li class="blockList">
<!-- ============ FIELD DETAIL =========== -->
<ul class="blockList">
<li class="blockList"><a name="field_detail">
<!--   -->
</a>
<h3>Field Detail</h3>
<a name="EPOCH">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>EPOCH</h4>
<pre>public static final&nbsp;double EPOCH</pre>
<div class="block">The first possible schedulable time.</div>
<dl><dt><span class="strong">See Also:</span></dt><dd><a href="../../constant-values.html#sim.engine.Schedule.EPOCH">Constant Field Values</a></dd></dl>
</li>
</ul>
<a name="BEFORE_SIMULATION">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>BEFORE_SIMULATION</h4>
<pre>public static final&nbsp;double BEFORE_SIMULATION</pre>
<div class="block">The time which indicates that the Schedule hasn't started yet. Less than EPOCH.</div>
<dl><dt><span class="strong">See Also:</span></dt><dd><a href="../../constant-values.html#sim.engine.Schedule.BEFORE_SIMULATION">Constant Field Values</a></dd></dl>
</li>
</ul>
<a name="AFTER_SIMULATION">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>AFTER_SIMULATION</h4>
<pre>public static final&nbsp;double AFTER_SIMULATION</pre>
<div class="block">The time which indicates that the Schedule is finished.  Equal positive infinity, and thus greater than any schedulable time.</div>
<dl><dt><span class="strong">See Also:</span></dt><dd><a href="../../constant-values.html#sim.engine.Schedule.AFTER_SIMULATION">Constant Field Values</a></dd></dl>
</li>
</ul>
<a name="EPOCH_PLUS_EPSILON">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>EPOCH_PLUS_EPSILON</h4>
<pre>public static final&nbsp;double EPOCH_PLUS_EPSILON</pre>
<div class="block">The second possible schedulable time.</div>
</li>
</ul>
<a name="MAXIMUM_INTEGER">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>MAXIMUM_INTEGER</h4>
<pre>public static final&nbsp;double MAXIMUM_INTEGER</pre>
<div class="block">The last time beyond which the schedule is no longer able to precisely maintain integer values due to loss of precision.  That is, MAXIMUM_INTEGER + 1.0 == MAXIMUM_INTEGER.</div>
<dl><dt><span class="strong">See Also:</span></dt><dd><a href="../../constant-values.html#sim.engine.Schedule.MAXIMUM_INTEGER">Constant Field Values</a></dd></dl>
</li>
</ul>
<a name="queue">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>queue</h4>
<pre>protected&nbsp;<a href="../../sim/util/Heap.html" title="class in sim.util">Heap</a> queue</pre>
<div class="block">The Schedule's queue.</div>
</li>
</ul>
<a name="time">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>time</h4>
<pre>protected&nbsp;double time</pre>
<div class="block">The current time, as returned by getTime().  
        If you modify this in a subclass, be sure to synchronize on Schedule.lock first.</div>
</li>
</ul>
<a name="steps">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>steps</h4>
<pre>protected&nbsp;long steps</pre>
<div class="block">The current steps, as returned by getSteps().  
        If you modify this in a subclass, be sure to synchronize on Schedule.lock first.</div>
</li>
</ul>
<a name="sealed">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>sealed</h4>
<pre>protected&nbsp;boolean sealed</pre>
<div class="block">Whether the schedule is sealed, as returned by isSealed().  
        If you modify this in a subclass, be sure to synchronize on Schedule.lock first.</div>
</li>
</ul>
<a name="lock">
<!--   -->
</a>
<ul class="blockListLast">
<li class="blockList">
<h4>lock</h4>
<pre>protected&nbsp;java.lang.Object lock</pre>
<div class="block">The schedule lock.  Many methods synchronize on this lock before modifying internal variables.</div>
</li>
</ul>
</li>
</ul>
<!-- ========= CONSTRUCTOR DETAIL ======== -->
<ul class="blockList">
<li class="blockList"><a name="constructor_detail">
<!--   -->
</a>
<h3>Constructor Detail</h3>
<a name="Schedule()">
<!--   -->
</a>
<ul class="blockListLast">
<li class="blockList">
<h4>Schedule</h4>
<pre>public&nbsp;Schedule()</pre>
<div class="block">Creates a Schedule.</div>
</li>
</ul>
</li>
</ul>
<!-- ============ METHOD DETAIL ========== -->
<ul class="blockList">
<li class="blockList"><a name="method_detail">
<!--   -->
</a>
<h3>Method Detail</h3>
<a name="createHeap()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>createHeap</h4>
<pre>protected&nbsp;<a href="../../sim/util/Heap.html" title="class in sim.util">Heap</a>&nbsp;createHeap()</pre>
<div class="block">Returns a Heap to be used by the Schedule.  By default, returns a
        binary heap.  Override this to provide your own
        subclass of Heap tuned for your particular problem.</div>
</li>
</ul>
<a name="time()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>time</h4>
<pre>public&nbsp;double&nbsp;time()</pre>
<div class="block"><span class="strong">Deprecated.</span>&nbsp;<i>use getTime()</i></div>
<div class="block">Returns the current timestep</div>
</li>
</ul>
<a name="getTime()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getTime</h4>
<pre>public&nbsp;double&nbsp;getTime()</pre>
<div class="block">Returns the current timestep</div>
</li>
</ul>
<a name="isSealed()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>isSealed</h4>
<pre>public&nbsp;boolean&nbsp;isSealed()</pre>
<div class="block">Returns whether or not the schedule is sealed (nothing more can be scheduled, even 
        if the schedule isn't at AFTER_SIMULATION yet).   Calling reset() will unseal
        a Schedule, and calling seal() will seal it.</div>
</li>
</ul>
<a name="getTimestamp(java.lang.String, java.lang.String)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getTimestamp</h4>
<pre>public&nbsp;java.lang.String&nbsp;getTimestamp(java.lang.String&nbsp;beforeSimulationString,
                            java.lang.String&nbsp;afterSimulationString)</pre>
<div class="block">Returns the current time in string format. If the time is BEFORE_SIMULATION, then beforeSimulationString is
        returned.  If the time is AFTER_SIMULATION, then afterSimulationString is returned.  Otherwise a numerical
        representation of the time is returned.</div>
</li>
</ul>
<a name="getTimestamp(double, java.lang.String, java.lang.String)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getTimestamp</h4>
<pre>public&nbsp;java.lang.String&nbsp;getTimestamp(double&nbsp;time,
                            java.lang.String&nbsp;beforeSimulationString,
                            java.lang.String&nbsp;afterSimulationString)</pre>
<div class="block">Returns a given time in string format. If the time is earlier than EPOCH (such as BEFORE_SIMULATION), then beforeSimulationString is
        returned.  If the time is AFTER_SIMULATION, then afterSimulationString is returned.  Otherwise a numerical
        representation of the time is returned.</div>
</li>
</ul>
<a name="getSteps()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getSteps</h4>
<pre>public&nbsp;long&nbsp;getSteps()</pre>
<div class="block">Returns the number of steps the Schedule has pulsed so far.</div>
</li>
</ul>
<a name="clear()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>clear</h4>
<pre>public&nbsp;void&nbsp;clear()</pre>
<div class="block">Empties out the schedule but does not reset the time or steps.  If you're
        looking for a way to kill your simulation from a Steppable, use SimState.kill() instead.  Note that
        any agents presently at THIS TIME STEP will STILL be stepped -- including possibly reinserting themselves
        in the schedule.</div>
</li>
</ul>
<a name="seal()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>seal</h4>
<pre>public&nbsp;void&nbsp;seal()</pre>
<div class="block">Seals the schedule: after a schedule is sealed, no further Steppables may be scheduled on it. 
        To unseal a schedule, you must reset() it.  If you're looking for a way to kill your simulation
        from a Steppable, use SimState.kill() instead.</div>
</li>
</ul>
<a name="reset()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>reset</h4>
<pre>public&nbsp;void&nbsp;reset()</pre>
<div class="block">Empties out the schedule and resets it to a pristine state BEFORE_SIMULATION, with steps = 0.  If you're
        looking for a way to kill your simulation from a Steppable, use SimState.kill() instead.</div>
</li>
</ul>
<a name="scheduleComplete()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>scheduleComplete</h4>
<pre>public&nbsp;boolean&nbsp;scheduleComplete()</pre>
<div class="block">Returns true if the schedule has nothing left to do.</div>
</li>
</ul>
<a name="merge(sim.engine.Schedule)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>merge</h4>
<pre>public&nbsp;void&nbsp;merge(<a href="../../sim/engine/Schedule.html" title="class in sim.engine">Schedule</a>&nbsp;other)</pre>
<div class="block">Merge a given schedule into this one.  The other schedule is not modified, but the queue of the
       original schedule is changed.  NOTE: this method is not threadsafe and should be only performed 
       when there are NO other threads which might want to manipulate the schedule.</div>
</li>
</ul>
<a name="step(sim.engine.SimState)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>step</h4>
<pre>public&nbsp;boolean&nbsp;step(<a href="../../sim/engine/SimState.html" title="class in sim.engine">SimState</a>&nbsp;state)</pre>
<div class="block">Steps the schedule, gathering and ordering all the items to step on the next time step (skipping
        blank time steps), and then stepping all of them in the decided order.  
        Returns FALSE if nothing was stepped -- the schedule is exhausted or time has run out.</div>
</li>
</ul>
<a name="scheduleOnce(sim.engine.Steppable)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>scheduleOnce</h4>
<pre>public&nbsp;boolean&nbsp;scheduleOnce(<a href="../../sim/engine/Steppable.html" title="interface in sim.engine">Steppable</a>&nbsp;event)</pre>
<div class="block">Schedules the event to occur at getTime() + 1.0, 0 ordering. If this is a valid time
        and event, schedules the event and returns TRUE.
        This method at present returns FALSE if the schedule cannot
        schedule any more events (it's sealed or the time is AFTER_SIMULATION), or if the
        event is being scheduled for AFTER_SIMULATION.  The method 
        throws an IllegalArgumentException if the event is being scheduled for an invalid time, or is null.</div>
</li>
</ul>
<a name="scheduleOnceIn(double, sim.engine.Steppable)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>scheduleOnceIn</h4>
<pre>public&nbsp;boolean&nbsp;scheduleOnceIn(double&nbsp;delta,
                     <a href="../../sim/engine/Steppable.html" title="interface in sim.engine">Steppable</a>&nbsp;event)</pre>
<div class="block">Schedules the event to occur at getTime() + delta, 0 ordering. If this is a valid time
        and event, schedules the event and returns TRUE.
        This method at present returns FALSE if the schedule cannot
        schedule any more events (it's sealed or the time is AFTER_SIMULATION), or if the
        event is being scheduled for AFTER_SIMULATION.  The method 
        throws an IllegalArgumentException if the event is being scheduled for an invalid time, or is null.</div>
</li>
</ul>
<a name="scheduleOnce(sim.engine.Steppable, int)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>scheduleOnce</h4>
<pre>public&nbsp;boolean&nbsp;scheduleOnce(<a href="../../sim/engine/Steppable.html" title="interface in sim.engine">Steppable</a>&nbsp;event,
                   int&nbsp;ordering)</pre>
<div class="block">Schedules the event to occur at getTime() + 1.0, and in the ordering provided. If this is a valid time
        and event, schedules the event and returns TRUE.
        This method at present returns FALSE if the schedule cannot
        schedule any more events (it's sealed or the time is AFTER_SIMULATION), or if the
        event is being scheduled for AFTER_SIMULATION.  The method 
        throws an IllegalArgumentException if the event is being scheduled for an invalid time, or is null.</div>
</li>
</ul>
<a name="scheduleOnceIn(double, sim.engine.Steppable, int)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>scheduleOnceIn</h4>
<pre>public&nbsp;boolean&nbsp;scheduleOnceIn(double&nbsp;delta,
                     <a href="../../sim/engine/Steppable.html" title="interface in sim.engine">Steppable</a>&nbsp;event,
                     int&nbsp;ordering)</pre>
<div class="block">Schedules the event to occur at getTime() + delta, and in the ordering provided. If this is a valid time
        and event, schedules the event and returns TRUE.
        This method at present returns FALSE if the schedule cannot
        schedule any more events (it's sealed or the time is AFTER_SIMULATION), or if the
        event is being scheduled for AFTER_SIMULATION.  The method 
        throws an IllegalArgumentException if the event is being scheduled for an invalid time, or is null.</div>
</li>
</ul>
<a name="scheduleOnce(double, sim.engine.Steppable)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>scheduleOnce</h4>
<pre>public&nbsp;boolean&nbsp;scheduleOnce(double&nbsp;time,
                   <a href="../../sim/engine/Steppable.html" title="interface in sim.engine">Steppable</a>&nbsp;event)</pre>
<div class="block">Schedules the event to occur at the provided time, 0 ordering.  If the getTime() == the provided
        time, then the event is instead scheduled to occur at getTime() + epsilon (the minimum possible next
        timestamp). If this is a valid time
        and event, schedules the event and returns TRUE.
        This method at present returns FALSE if the schedule cannot
        schedule any more events (it's sealed or the time is AFTER_SIMULATION), or if the
        event is being scheduled for AFTER_SIMULATION.  The method 
        throws an IllegalArgumentException if the event is being scheduled for an invalid time, or is null.</div>
</li>
</ul>
<a name="scheduleOnce(double, int, sim.engine.Steppable)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>scheduleOnce</h4>
<pre>public&nbsp;boolean&nbsp;scheduleOnce(double&nbsp;time,
                   int&nbsp;ordering,
                   <a href="../../sim/engine/Steppable.html" title="interface in sim.engine">Steppable</a>&nbsp;event)</pre>
<div class="block">Schedules the event to occur at the provided time, and in the ordering provided.  If the getTime() == the provided
        time, then the event is instead scheduled to occur at getTime() + epsilon (the minimum possible next
        timestamp). If this is a valid time, ordering,
        and event, schedules the event and returns TRUE.
        This method at present returns FALSE if the schedule cannot
        schedule any more events (it's sealed or the time is AFTER_SIMULATION), or if the
        event is being scheduled for AFTER_SIMULATION.  The method 
        throws an IllegalArgumentException if the event is being scheduled for an invalid time, or is null.</div>
</li>
</ul>
<a name="scheduleOnce(sim.engine.Schedule.Key, sim.engine.Steppable)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>scheduleOnce</h4>
<pre>protected&nbsp;boolean&nbsp;scheduleOnce(<a href="../../sim/engine/Schedule.Key.html" title="class in sim.engine">Schedule.Key</a>&nbsp;key,
                   <a href="../../sim/engine/Steppable.html" title="interface in sim.engine">Steppable</a>&nbsp;event)</pre>
<div class="block">Schedules an item. 
        This method at present returns FALSE if the schedule cannot
        schedule any more events (it's sealed or the time is AFTER_SIMULATION), or if the
        event is being scheduled for AFTER_SIMULATION.  The method 
        throws an IllegalArgumentException if the event is being scheduled for an invalid time, or is null.</div>
</li>
</ul>
<a name="scheduleRepeating(sim.engine.Steppable)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>scheduleRepeating</h4>
<pre>public&nbsp;<a href="../../sim/engine/Stoppable.html" title="interface in sim.engine">Stoppable</a>&nbsp;scheduleRepeating(<a href="../../sim/engine/Steppable.html" title="interface in sim.engine">Steppable</a>&nbsp;event)</pre>
<div class="block">Schedules the event to recur at an interval of 1.0 starting at getTime() + 1.0, and at 0 ordering.
        If this is a valid event, schedules the event and returns a Stoppable, else returns null.
        The recurrence will continue until getTime() >= AFTER_SIMULATION, the Schedule is cleared out,
        or the Stoppable's stop() method is called, whichever happens first.

        <p>This method at present returns null if the schedule cannot
        schedule any more events (it's sealed or the time is AFTER_SIMULATION).  The method 
        throws an IllegalArgumentException if the event is being scheduled for an invalid time, or is null. 

        <p> Note that calling stop() on the Stoppable
        will not only stop the repeating, but will <i>also</i> make the Schedule completely
        forget (lose the pointer to) the Steppable scheduled here.  This is particularly useful
        if you need to make the Schedule NOT serialize certain Steppable objects.</div>
</li>
</ul>
<a name="scheduleRepeating(sim.engine.Steppable, double)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>scheduleRepeating</h4>
<pre>public&nbsp;<a href="../../sim/engine/Stoppable.html" title="interface in sim.engine">Stoppable</a>&nbsp;scheduleRepeating(<a href="../../sim/engine/Steppable.html" title="interface in sim.engine">Steppable</a>&nbsp;event,
                          double&nbsp;interval)</pre>
<div class="block">Schedules the event to recur at the specified interval starting at getTime() + interval, and at 0 ordering.
        If this is a valid interval (must be > 0)
        and event, schedules the event and returns a Stoppable, else returns null.
        The recurrence will continue until getTime() >= AFTER_SIMULATION, the Schedule is cleared out,
        or the Stoppable's stop() method is called, whichever happens first.

        <p>This method at present returns null if the schedule cannot
        schedule any more events (it's sealed or the time is AFTER_SIMULATION).  The method 
        throws an IllegalArgumentException if the event is being scheduled for an invalid time, or is null. 

        <p> Note that calling stop() on the Stoppable
        will not only stop the repeating, but will <i>also</i> make the Schedule completely
        forget (lose the pointer to) the Steppable scheduled here.  This is particularly useful
        if you need to make the Schedule NOT serialize certain Steppable objects.</div>
</li>
</ul>
<a name="scheduleRepeating(sim.engine.Steppable, int, double)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>scheduleRepeating</h4>
<pre>public&nbsp;<a href="../../sim/engine/Stoppable.html" title="interface in sim.engine">Stoppable</a>&nbsp;scheduleRepeating(<a href="../../sim/engine/Steppable.html" title="interface in sim.engine">Steppable</a>&nbsp;event,
                          int&nbsp;ordering,
                          double&nbsp;interval)</pre>
<div class="block">Schedules the event to recur at the specified interval starting at getTime() + interval, and at the provided ordering.
        If this is a valid interval (must be > 0)
        and event, schedules the event and returns a Stoppable, else returns null.
        The recurrence will continue until getTime() >= AFTER_SIMULATION, the Schedule is cleared out,
        or the Stoppable's stop() method is called, whichever happens first.

        <p>This method at present returns null if the schedule cannot
        schedule any more events (it's sealed or the time is AFTER_SIMULATION).  The method 
        throws an IllegalArgumentException if the event is being scheduled for an invalid time, or is null. 

        <p> Note that calling stop() on the Stoppable
        will not only stop the repeating, but will <i>also</i> make the Schedule completely
        forget (lose the pointer to) the Steppable scheduled here.  This is particularly useful
        if you need to make the Schedule NOT serialize certain Steppable objects.</div>
</li>
</ul>
<a name="scheduleRepeating(double, sim.engine.Steppable)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>scheduleRepeating</h4>
<pre>public&nbsp;<a href="../../sim/engine/Stoppable.html" title="interface in sim.engine">Stoppable</a>&nbsp;scheduleRepeating(double&nbsp;time,
                          <a href="../../sim/engine/Steppable.html" title="interface in sim.engine">Steppable</a>&nbsp;event)</pre>
<div class="block">Schedules the event to recur at the specified interval starting at the provided time, and at 0 ordering.
        If the getTime() == the provided
        time, then the first event is instead scheduled to occur at getTime() + epsilon (the minimum possible next
        timestamp). If this is a valid time, ordering, interval (must be positive), 
        and event, schedules the event and returns a Stoppable, else returns null.
        The recurrence will continue until getTime() >= AFTER_SIMULATION, the Schedule is cleared out,
        or the Stoppable's stop() method is called, whichever happens first.

        <p>This method at present returns null if the schedule cannot
        schedule any more events (it's sealed or the time is AFTER_SIMULATION).  The method 
        throws an IllegalArgumentException if the event is being scheduled for an invalid time, or is null. 

        <p> Note that calling stop() on the Stoppable
        will not only stop the repeating, but will <i>also</i> make the Schedule completely
        forget (lose the pointer to) the Steppable scheduled here.  This is particularly useful
        if you need to make the Schedule NOT serialize certain Steppable objects.</div>
</li>
</ul>
<a name="scheduleRepeating(double, sim.engine.Steppable, double)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>scheduleRepeating</h4>
<pre>public&nbsp;<a href="../../sim/engine/Stoppable.html" title="interface in sim.engine">Stoppable</a>&nbsp;scheduleRepeating(double&nbsp;time,
                          <a href="../../sim/engine/Steppable.html" title="interface in sim.engine">Steppable</a>&nbsp;event,
                          double&nbsp;interval)</pre>
<div class="block">Schedules the event to recur at the specified interval starting at the provided time, 
        in ordering 0.  If the getTime() == the provided
        time, then the first event is instead scheduled to occur at getTime() + epsilon (the minimum possible next
        timestamp). If this is a valid time, interval (must be > 0), 
        and event, schedules the event and returns a Stoppable, else returns null.
        The recurrence will continue until getTime() >= AFTER_SIMULATION, the Schedule is cleared out,
        or the Stoppable's stop() method is called, whichever happens first.

        <p>This method at present returns null if the schedule cannot
        schedule any more events (it's sealed or the time is AFTER_SIMULATION).  The method 
        throws an IllegalArgumentException if the event is being scheduled for an invalid time, or is null. 

        <p> Note that calling stop() on the Stoppable
        will not only stop the repeating, but will <i>also</i> make the Schedule completely
        forget (lose the pointer to) the Steppable scheduled here.  This is particularly useful
        if you need to make the Schedule NOT serialize certain Steppable objects.</div>
</li>
</ul>
<a name="scheduleRepeating(double, int, sim.engine.Steppable)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>scheduleRepeating</h4>
<pre>public&nbsp;<a href="../../sim/engine/Stoppable.html" title="interface in sim.engine">Stoppable</a>&nbsp;scheduleRepeating(double&nbsp;time,
                          int&nbsp;ordering,
                          <a href="../../sim/engine/Steppable.html" title="interface in sim.engine">Steppable</a>&nbsp;event)</pre>
<div class="block">Schedules the event to recur at an interval of 1.0 starting at the provided time, 
        and in the ordering provided.  If the getTime() == the provided
        time, then the first event is instead scheduled to occur at getTime() + epsilon (the minimum possible next
        timestamp). If this is a valid time, ordering,
        and event, schedules the event and returns a Stoppable, else returns null.
        The recurrence will continue until getTime() >= AFTER_SIMULATION, the Schedule is cleared out,
        or the Stoppable's stop() method is called, whichever happens first.

        <p>This method at present returns null if the schedule cannot
        schedule any more events (it's sealed or the time is AFTER_SIMULATION).  The method 
        throws an IllegalArgumentException if the event is being scheduled for an invalid time, or is null. 

        <p> Note that calling stop() on the Stoppable
        will not only stop the repeating, but will <i>also</i> make the Schedule completely
        forget (lose the pointer to) the Steppable scheduled here.  This is particularly useful
        if you need to make the Schedule NOT serialize certain Steppable objects.</div>
</li>
</ul>
<a name="scheduleRepeating(double, int, sim.engine.Steppable, double)">
<!--   -->
</a>
<ul class="blockListLast">
<li class="blockList">
<h4>scheduleRepeating</h4>
<pre>public&nbsp;<a href="../../sim/engine/Stoppable.html" title="interface in sim.engine">Stoppable</a>&nbsp;scheduleRepeating(double&nbsp;time,
                          int&nbsp;ordering,
                          <a href="../../sim/engine/Steppable.html" title="interface in sim.engine">Steppable</a>&nbsp;event,
                          double&nbsp;interval)</pre>
<div class="block">Schedules the event to recur at the specified interval starting at the provided time, 
        and in the ordering provided.  If the getTime() == the provided
        time, then the first event is instead scheduled to occur at getTime() + epsilon (the minimum possible next
        timestamp). If this is a valid time, ordering, interval (must be > 0), 
        and event, schedules the event and returns a Stoppable.
        The recurrence will continue until getTime() >= AFTER_SIMULATION, the Schedule is cleared out,
        or the Stoppable's stop() method is called, whichever happens first.

        <p>This method at present returns null if the schedule cannot
        schedule any more events (it's sealed or the time is AFTER_SIMULATION).  The method 
        throws an IllegalArgumentException if the event is being scheduled for an invalid time, or is null. 

        <p> Note that calling stop() on the Stoppable
        will not only stop the repeating, but will <i>also</i> make the Schedule completely 
        forget (lose the pointer to) the Steppable scheduled here.  This is particularly useful
        if you need to make the Schedule NOT serialize certain Steppable objects.</div>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
</div>
<!-- ========= END OF CLASS DATA ========= -->
<!-- ======= START OF BOTTOM NAVBAR ====== -->
<div class="bottomNav"><a name="navbar_bottom">
<!--   -->
</a><a href="#skip-navbar_bottom" title="Skip navigation links"></a><a name="navbar_bottom_firstrow">
<!--   -->
</a>
<ul class="navList" title="Navigation">
<li><a href="../../overview-summary.html">Overview</a></li>
<li><a href="package-summary.html">Package</a></li>
<li class="navBarCell1Rev">Class</li>
<li><a href="package-tree.html">Tree</a></li>
<li><a href="../../deprecated-list.html">Deprecated</a></li>
<li><a href="../../index-all.html">Index</a></li>
<li><a href="../../help-doc.html">Help</a></li>
</ul>
</div>
<div class="subNav">
<ul class="navList">
<li><a href="../../sim/engine/Repeat.html" title="class in sim.engine"><span class="strong">Prev Class</span></a></li>
<li><a href="../../sim/engine/Schedule.Key.html" title="class in sim.engine"><span class="strong">Next Class</span></a></li>
</ul>
<ul class="navList">
<li><a href="../../index.html?sim/engine/Schedule.html" target="_top">Frames</a></li>
<li><a href="Schedule.html" target="_top">No Frames</a></li>
</ul>
<ul class="navList" id="allclasses_navbar_bottom">
<li><a href="../../allclasses-noframe.html">All Classes</a></li>
</ul>
<div>
<script type="text/javascript"><!--
  allClassesLink = document.getElementById("allclasses_navbar_bottom");
  if(window==top) {
    allClassesLink.style.display = "block";
  }
  else {
    allClassesLink.style.display = "none";
  }
  //-->
</script>
</div>
<div>
<ul class="subNavList">
<li>Summary:&nbsp;</li>
<li><a href="#nested_class_summary">Nested</a>&nbsp;|&nbsp;</li>
<li><a href="#field_summary">Field</a>&nbsp;|&nbsp;</li>
<li><a href="#constructor_summary">Constr</a>&nbsp;|&nbsp;</li>
<li><a href="#method_summary">Method</a></li>
</ul>
<ul class="subNavList">
<li>Detail:&nbsp;</li>
<li><a href="#field_detail">Field</a>&nbsp;|&nbsp;</li>
<li><a href="#constructor_detail">Constr</a>&nbsp;|&nbsp;</li>
<li><a href="#method_detail">Method</a></li>
</ul>
</div>
<a name="skip-navbar_bottom">
<!--   -->
</a></div>
<!-- ======== END OF BOTTOM NAVBAR ======= -->
</body>
</html>
