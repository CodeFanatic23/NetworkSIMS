<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!-- NewPage -->
<html lang="en">
<head>
<!-- Generated by javadoc (version 1.7.0_51) on Fri Jun 19 12:12:04 EDT 2015 -->
<title>Grid2D</title>
<meta name="date" content="2015-06-19">
<link rel="stylesheet" type="text/css" href="../../../stylesheet.css" title="Style">
</head>
<body>
<script type="text/javascript"><!--
    if (location.href.indexOf('is-external=true') == -1) {
        parent.document.title="Grid2D";
    }
//-->
</script>
<noscript>
<div>JavaScript is disabled on your browser.</div>
</noscript>
<!-- ========= START OF TOP NAVBAR ======= -->
<div class="topNav"><a name="navbar_top">
<!--   -->
</a><a href="#skip-navbar_top" title="Skip navigation links"></a><a name="navbar_top_firstrow">
<!--   -->
</a>
<ul class="navList" title="Navigation">
<li><a href="../../../overview-summary.html">Overview</a></li>
<li><a href="package-summary.html">Package</a></li>
<li class="navBarCell1Rev">Class</li>
<li><a href="package-tree.html">Tree</a></li>
<li><a href="../../../deprecated-list.html">Deprecated</a></li>
<li><a href="../../../index-all.html">Index</a></li>
<li><a href="../../../help-doc.html">Help</a></li>
</ul>
</div>
<div class="subNav">
<ul class="navList">
<li><a href="../../../sim/field/grid/DoubleGrid3D.html" title="class in sim.field.grid"><span class="strong">Prev Class</span></a></li>
<li><a href="../../../sim/field/grid/Grid3D.html" title="interface in sim.field.grid"><span class="strong">Next Class</span></a></li>
</ul>
<ul class="navList">
<li><a href="../../../index.html?sim/field/grid/Grid2D.html" target="_top">Frames</a></li>
<li><a href="Grid2D.html" target="_top">No Frames</a></li>
</ul>
<ul class="navList" id="allclasses_navbar_top">
<li><a href="../../../allclasses-noframe.html">All Classes</a></li>
</ul>
<div>
<script type="text/javascript"><!--
  allClassesLink = document.getElementById("allclasses_navbar_top");
  if(window==top) {
    allClassesLink.style.display = "block";
  }
  else {
    allClassesLink.style.display = "none";
  }
  //-->
</script>
</div>
<div>
<ul class="subNavList">
<li>Summary:&nbsp;</li>
<li>Nested&nbsp;|&nbsp;</li>
<li><a href="#field_summary">Field</a>&nbsp;|&nbsp;</li>
<li>Constr&nbsp;|&nbsp;</li>
<li><a href="#method_summary">Method</a></li>
</ul>
<ul class="subNavList">
<li>Detail:&nbsp;</li>
<li><a href="#field_detail">Field</a>&nbsp;|&nbsp;</li>
<li>Constr&nbsp;|&nbsp;</li>
<li><a href="#method_detail">Method</a></li>
</ul>
</div>
<a name="skip-navbar_top">
<!--   -->
</a></div>
<!-- ========= END OF TOP NAVBAR ========= -->
<!-- ======== START OF CLASS DATA ======== -->
<div class="header">
<div class="subTitle">sim.field.grid</div>
<h2 title="Interface Grid2D" class="title">Interface Grid2D</h2>
</div>
<div class="contentContainer">
<div class="description">
<ul class="blockList">
<li class="blockList">
<dl>
<dt>All Superinterfaces:</dt>
<dd>java.io.Serializable</dd>
</dl>
<dl>
<dt>All Known Implementing Classes:</dt>
<dd><a href="../../../sim/field/grid/AbstractGrid2D.html" title="class in sim.field.grid">AbstractGrid2D</a>, <a href="../../../sim/field/grid/DenseGrid2D.html" title="class in sim.field.grid">DenseGrid2D</a>, <a href="../../../sim/field/grid/DoubleGrid2D.html" title="class in sim.field.grid">DoubleGrid2D</a>, <a href="../../../sim/field/grid/IntGrid2D.html" title="class in sim.field.grid">IntGrid2D</a>, <a href="../../../sim/field/grid/ObjectGrid2D.html" title="class in sim.field.grid">ObjectGrid2D</a>, <a href="../../../sim/field/grid/SparseGrid2D.html" title="class in sim.field.grid">SparseGrid2D</a></dd>
</dl>
<hr>
<br>
<pre>public interface <span class="strong">Grid2D</span>
extends java.io.Serializable</pre>
<div class="block">Define basic neighborhood functions for 2D Grids.  The basic interface defines a width and a height
    (not all grids require a width and a height unless you're doing toroidal grids), and basic math for
    toroidal computation, hex grid location, and triangular grid location.
    
    <H3>Toroidal Computation</H3>
    
    <p>If you're using the Grid to define a toroidal (wrap-around) world, you can use the <b>tx</b>
    and <b>ty</b> methods to simplify the math for you.  For example, to increment in the x direction,
    including wrap-around, you can do:  x = tx(x+1).
    
    <p>If you're sure that the values you'd pass into the toroidal functions would not wander off more than
    a grid dimension in either direction (height, width), you can use the slightly faster toroidal functions
    <b>stx</b> and <b>sty</b> instead.  For example, to increment in the x direction,
    including wrap-around, you can do:  x = stx(x+1).  See the documentation on these functions for
    when they're appropriate to use.  Under most common situations, they're okay.

    <p>In HotSpot 1.4.1, stx, and sty are inlined.  In Hotspot 1.3.1, they are not (they contain if-statements).
    
    <H3>Hex Grid Computation</H3>
    Grids can be used for both squares and hex grids.  Hex grids are stored in an ordinary
    rectangular array and are defined as follows:
    
<pre>
<tt>
        (0,0)            (2,0)            (4,0)            (6,0)            ...
                (1,0)            (3,0)            (5,0)            (7,0)            ...
        (0,1)            (2,1)            (4,1)            (6,1)            ...
                (1,1)            (3,1)            (5,1)            (7,1)            ...
        (0,2)            (2,2)            (4,2)            (6,2)            ...
                (1,2)            (3,2)            (5,2)            (7,2)            ...
        ...              ...              ...              ...              ...
                ...              ...              ...              ...              ...
</tt>
</pre>    
    
<p>The rules moving from a hex location (at CENTER) to another one are as follows:

<pre>
<tt>
                                                UP
                                                x
            UPLEFT                            y - 1                   UPRIGHT
            x - 1                                                     x + 1
            ((x % 2) == 0) ? y - 1 : y                CENTER                  ((x % 2) == 0) ? y - 1 : y
                                                x
            DOWNLEFT                            y                                             DOWNRIGHT
            x - 1                                                     x + 1
            ((x % 2) == 0) ? y : y + 1                DOWN                    ((x % 2) == 0) ? y : y + 1
                                                x
                                                                                              y + 1

</tt>
</pre>
   NOTE: (x % 2 == 0), that is, "x is even", may be written instead in this faster way: ((x & 1) == 0)

 <p>Because the math is a little hairy, we've provided the math for the UPLEFT, UPRIGHT, DOWNLEFT,
  and DOWNRIGHT directions for you.  For example, the UPLEFT location from [x,y] is at
  [ulx(x,y) , uly(x,y)].  Additionally, the toroidal methods can be used in conjunction with the 
  hex methods to implement a toroidal hex grid.  Be sure to  <b>To use a toroidal hex grid properly,
   you must ensure that height of the grid is an even number</b>.  For example, the toroidal 
   UPLEFT X location is at tx(ulx(x,y)) and the UPLEFT Y location is at ty(uly(x,y)).  Similarly, 
   you can use stx and sty.

 <p>While this interface defines various methods common to many grids, you should endeavor not to 
 call these grids casted into this interface: it's slow.  If you call the grids' methods directly 
 by their class, their methods are almost certain to be inlined into your code, which is very fast.
 
     <H3>Triangular Grid Computation</H3>
    
    Grids can also be used for triangular grids instead of squares.  Triangular grids look like this:

    <pre><tt>
    -------------------------
    \(0,0)/ \(2,0)/ \(4,0)/ \
     \   /   \   /   \   /   \    ...
      \ /(1,0)\ /(3,0)\ /(5,0)\
       -------------------------
      / \(1,1)/ \(3,1)/ \(5,1)/
     /   \   /   \   /   \   /    ...
    /(0,1)\ /(2,1)\ /(4,1)\ /
    -------------------------
    \(0,2)/ \(2,2)/ \(4,2)/ \
     \   /   \   /   \   /   \    ...
      \ /(1,2)\ /(3,2)\ /(5,2)\
       -------------------------
      / \(1,3)/ \(3,3)/ \(5,3)/
     /   \   /   \   /   \   /    ...
    /(0,3)\ /(2,3)\ /(4,3)\ /
    -------------------------
               .
               .
               .
    </tt></pre> 

    <p>How do you get around such a beast?  Piece of cake!  Well, to go to your right or left 
    neighbor, you just add or subtract the X value.  To go to your up or down neighbor, all you 
    do is add or subtract the Y value.  All you need to know is if your triangle has an edge on 
    the top (so you can go up) or an edge on the bottom (so you can go down).  The functions TRB 
    (triangle with horizontal edge on 'bottom') and TRT (triangle with horizontal edge on 'top') 
    will tell you this.

    <p>Like the others, the triangular grid can <i>also</i> be used in toroidal fashion, and the 
    toroidal functions should work properly with it. <b>To use a <i>toroidal</i> triangular grid, 
    you should ensure that your grid's length and width are <i>both</i> even numbers.</b>

    <p>We'll provide a distance-measure function for triangular grids just as soon as we figure out
    what the heck one looks like.  :-)</div>
</li>
</ul>
</div>
<div class="summary">
<ul class="blockList">
<li class="blockList">
<!-- =========== FIELD SUMMARY =========== -->
<ul class="blockList">
<li class="blockList"><a name="field_summary">
<!--   -->
</a>
<h3>Field Summary</h3>
<table class="overviewSummary" border="0" cellpadding="3" cellspacing="0" summary="Field Summary table, listing fields, and an explanation">
<caption><span>Fields</span><span class="tabEnd">&nbsp;</span></caption>
<tr>
<th class="colFirst" scope="col">Modifier and Type</th>
<th class="colLast" scope="col">Field and Description</th>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><strong><a href="../../../sim/field/grid/Grid2D.html#ALL">ALL</a></strong></code>
<div class="block">"All" measurement rule for raidal neighborhood lookup.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><strong><a href="../../../sim/field/grid/Grid2D.html#ANY">ANY</a></strong></code>
<div class="block">"Any" measurement rule for raidal neighborhood lookup.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><strong><a href="../../../sim/field/grid/Grid2D.html#ANY_SIZE">ANY_SIZE</a></strong></code>
<div class="block">Pass this into buildMap to indicate that it should make a map of any size it likes.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><strong><a href="../../../sim/field/grid/Grid2D.html#BOUNDED">BOUNDED</a></strong></code>
<div class="block">Bounded Mode for neighborhood lookup.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><strong><a href="../../../sim/field/grid/Grid2D.html#CENTER">CENTER</a></strong></code>
<div class="block">Center measurement rule for raidal neighborhood lookup.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><strong><a href="../../../sim/field/grid/Grid2D.html#TOROIDAL">TOROIDAL</a></strong></code>
<div class="block">Bounded Mode for toroidal lookup.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><strong><a href="../../../sim/field/grid/Grid2D.html#UNBOUNDED">UNBOUNDED</a></strong></code>
<div class="block">Bounded Mode for neighborhood lookup.</div>
</td>
</tr>
</table>
</li>
</ul>
<!-- ========== METHOD SUMMARY =========== -->
<ul class="blockList">
<li class="blockList"><a name="method_summary">
<!--   -->
</a>
<h3>Method Summary</h3>
<table class="overviewSummary" border="0" cellpadding="3" cellspacing="0" summary="Method Summary table, listing methods, and an explanation">
<caption><span>Methods</span><span class="tabEnd">&nbsp;</span></caption>
<tr>
<th class="colFirst" scope="col">Modifier and Type</th>
<th class="colLast" scope="col">Method and Description</th>
</tr>
<tr class="altColor">
<td class="colFirst"><code>java.util.Map</code></td>
<td class="colLast"><code><strong><a href="../../../sim/field/grid/Grid2D.html#buildMap(int)">buildMap</a></strong>(int&nbsp;size)</code>
<div class="block">Creates a map of the provided size (or any size it likes if ANY_SIZE is passed in).</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>java.util.Map</code></td>
<td class="colLast"><code><strong><a href="../../../sim/field/grid/Grid2D.html#buildMap(java.util.Map)">buildMap</a></strong>(java.util.Map&nbsp;other)</code>
<div class="block">Creates a Map which is a copy of another.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>int</code></td>
<td class="colLast"><code><strong><a href="../../../sim/field/grid/Grid2D.html#dlx(int, int)">dlx</a></strong>(int&nbsp;x,
   int&nbsp;y)</code>
<div class="block">Hex downleft x.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>int</code></td>
<td class="colLast"><code><strong><a href="../../../sim/field/grid/Grid2D.html#dly(int, int)">dly</a></strong>(int&nbsp;x,
   int&nbsp;y)</code>
<div class="block">Hex downleft y.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>int</code></td>
<td class="colLast"><code><strong><a href="../../../sim/field/grid/Grid2D.html#downx(int, int)">downx</a></strong>(int&nbsp;x,
     int&nbsp;y)</code>
<div class="block">Hex down x.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>int</code></td>
<td class="colLast"><code><strong><a href="../../../sim/field/grid/Grid2D.html#downy(int, int)">downy</a></strong>(int&nbsp;x,
     int&nbsp;y)</code>
<div class="block">Hex down y.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>int</code></td>
<td class="colLast"><code><strong><a href="../../../sim/field/grid/Grid2D.html#drx(int, int)">drx</a></strong>(int&nbsp;x,
   int&nbsp;y)</code>
<div class="block">Hex downright x.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>int</code></td>
<td class="colLast"><code><strong><a href="../../../sim/field/grid/Grid2D.html#dry(int, int)">dry</a></strong>(int&nbsp;x,
   int&nbsp;y)</code>
<div class="block">Hex downright y.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>int</code></td>
<td class="colLast"><code><strong><a href="../../../sim/field/grid/Grid2D.html#getHeight()">getHeight</a></strong>()</code>
<div class="block">Returns the width of the field.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><strong><a href="../../../sim/field/grid/Grid2D.html#getHexagonalLocations(int, int, int, int, boolean, sim.util.IntBag, sim.util.IntBag)">getHexagonalLocations</a></strong>(int&nbsp;x,
                     int&nbsp;y,
                     int&nbsp;dist,
                     int&nbsp;mode,
                     boolean&nbsp;includeOrigin,
                     <a href="../../../sim/util/IntBag.html" title="class in sim.util">IntBag</a>&nbsp;xPos,
                     <a href="../../../sim/util/IntBag.html" title="class in sim.util">IntBag</a>&nbsp;yPos)</code>
<div class="block">Gets all neighbors located within the hexagon centered at (X,Y) and 2*dist+1 cells from point to opposite point 
 inclusive.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><strong><a href="../../../sim/field/grid/Grid2D.html#getMooreLocations(int, int, int, int, boolean, sim.util.IntBag, sim.util.IntBag)">getMooreLocations</a></strong>(int&nbsp;x,
                 int&nbsp;y,
                 int&nbsp;dist,
                 int&nbsp;mode,
                 boolean&nbsp;includeOrigin,
                 <a href="../../../sim/util/IntBag.html" title="class in sim.util">IntBag</a>&nbsp;xPos,
                 <a href="../../../sim/util/IntBag.html" title="class in sim.util">IntBag</a>&nbsp;yPos)</code>
<div class="block">Gets all neighbors of a location that satisfy max( abs(x-X) , abs(y-Y) ) <= dist.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><strong><a href="../../../sim/field/grid/Grid2D.html#getNeighborsHamiltonianDistance(int, int, int, boolean, sim.util.IntBag, sim.util.IntBag)">getNeighborsHamiltonianDistance</a></strong>(int&nbsp;x,
                               int&nbsp;y,
                               int&nbsp;dist,
                               boolean&nbsp;toroidal,
                               <a href="../../../sim/util/IntBag.html" title="class in sim.util">IntBag</a>&nbsp;xPos,
                               <a href="../../../sim/util/IntBag.html" title="class in sim.util">IntBag</a>&nbsp;yPos)</code>
<div class="block"><strong>Deprecated.</strong>&nbsp;&nbsp;</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><strong><a href="../../../sim/field/grid/Grid2D.html#getNeighborsHexagonalDistance(int, int, int, boolean, sim.util.IntBag, sim.util.IntBag)">getNeighborsHexagonalDistance</a></strong>(int&nbsp;x,
                             int&nbsp;y,
                             int&nbsp;dist,
                             boolean&nbsp;toroidal,
                             <a href="../../../sim/util/IntBag.html" title="class in sim.util">IntBag</a>&nbsp;xPos,
                             <a href="../../../sim/util/IntBag.html" title="class in sim.util">IntBag</a>&nbsp;yPos)</code>
<div class="block"><strong>Deprecated.</strong>&nbsp;&nbsp;</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><strong><a href="../../../sim/field/grid/Grid2D.html#getNeighborsMaxDistance(int, int, int, boolean, sim.util.IntBag, sim.util.IntBag)">getNeighborsMaxDistance</a></strong>(int&nbsp;x,
                       int&nbsp;y,
                       int&nbsp;dist,
                       boolean&nbsp;toroidal,
                       <a href="../../../sim/util/IntBag.html" title="class in sim.util">IntBag</a>&nbsp;xPos,
                       <a href="../../../sim/util/IntBag.html" title="class in sim.util">IntBag</a>&nbsp;yPos)</code>
<div class="block"><strong>Deprecated.</strong>&nbsp;&nbsp;</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><strong><a href="../../../sim/field/grid/Grid2D.html#getRadialLocations(int, int, double, int, boolean, sim.util.IntBag, sim.util.IntBag)">getRadialLocations</a></strong>(int&nbsp;x,
                  int&nbsp;y,
                  double&nbsp;dist,
                  int&nbsp;mode,
                  boolean&nbsp;includeOrigin,
                  <a href="../../../sim/util/IntBag.html" title="class in sim.util">IntBag</a>&nbsp;xPos,
                  <a href="../../../sim/util/IntBag.html" title="class in sim.util">IntBag</a>&nbsp;yPos)</code>
<div class="block">Gets all neighbors overlapping with a circular region centered at (X,Y) and with a radius of dist.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><strong><a href="../../../sim/field/grid/Grid2D.html#getRadialLocations(int, int, double, int, boolean, int, boolean, sim.util.IntBag, sim.util.IntBag)">getRadialLocations</a></strong>(int&nbsp;x,
                  int&nbsp;y,
                  double&nbsp;dist,
                  int&nbsp;mode,
                  boolean&nbsp;includeOrigin,
                  int&nbsp;measurementRule,
                  boolean&nbsp;closed,
                  <a href="../../../sim/util/IntBag.html" title="class in sim.util">IntBag</a>&nbsp;xPos,
                  <a href="../../../sim/util/IntBag.html" title="class in sim.util">IntBag</a>&nbsp;yPos)</code>
<div class="block">Gets all neighbors overlapping with a circular region centered at (X,Y) and with a radius of dist.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><strong><a href="../../../sim/field/grid/Grid2D.html#getVonNeumannLocations(int, int, int, int, boolean, sim.util.IntBag, sim.util.IntBag)">getVonNeumannLocations</a></strong>(int&nbsp;x,
                      int&nbsp;y,
                      int&nbsp;dist,
                      int&nbsp;mode,
                      boolean&nbsp;includeOrigin,
                      <a href="../../../sim/util/IntBag.html" title="class in sim.util">IntBag</a>&nbsp;xPos,
                      <a href="../../../sim/util/IntBag.html" title="class in sim.util">IntBag</a>&nbsp;yPos)</code>
<div class="block">Gets all neighbors of a location that satisfy abs(x-X) + abs(y-Y) <= dist.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>int</code></td>
<td class="colLast"><code><strong><a href="../../../sim/field/grid/Grid2D.html#getWidth()">getWidth</a></strong>()</code>
<div class="block">Returns the width of the field.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>int</code></td>
<td class="colLast"><code><strong><a href="../../../sim/field/grid/Grid2D.html#stx(int)">stx</a></strong>(int&nbsp;x)</code>
<div class="block">Simple [and fast] toroidal x.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>int</code></td>
<td class="colLast"><code><strong><a href="../../../sim/field/grid/Grid2D.html#sty(int)">sty</a></strong>(int&nbsp;y)</code>
<div class="block">Simple [and fast] toroidal y.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><strong><a href="../../../sim/field/grid/Grid2D.html#trb(int, int)">trb</a></strong>(int&nbsp;x,
   int&nbsp;y)</code>
<div class="block">Horizontal edge is on the bottom for triangle.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><strong><a href="../../../sim/field/grid/Grid2D.html#trt(int, int)">trt</a></strong>(int&nbsp;x,
   int&nbsp;y)</code>
<div class="block">Horizontal edge is on the top for triangle.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>int</code></td>
<td class="colLast"><code><strong><a href="../../../sim/field/grid/Grid2D.html#tx(int)">tx</a></strong>(int&nbsp;x)</code>
<div class="block">Toroidal x.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>int</code></td>
<td class="colLast"><code><strong><a href="../../../sim/field/grid/Grid2D.html#ty(int)">ty</a></strong>(int&nbsp;y)</code>
<div class="block">Toroidal y.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>int</code></td>
<td class="colLast"><code><strong><a href="../../../sim/field/grid/Grid2D.html#ulx(int, int)">ulx</a></strong>(int&nbsp;x,
   int&nbsp;y)</code>
<div class="block">Hex upleft x.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>int</code></td>
<td class="colLast"><code><strong><a href="../../../sim/field/grid/Grid2D.html#uly(int, int)">uly</a></strong>(int&nbsp;x,
   int&nbsp;y)</code>
<div class="block">Hex upleft y.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>int</code></td>
<td class="colLast"><code><strong><a href="../../../sim/field/grid/Grid2D.html#upx(int, int)">upx</a></strong>(int&nbsp;x,
   int&nbsp;y)</code>
<div class="block">Hex up x.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>int</code></td>
<td class="colLast"><code><strong><a href="../../../sim/field/grid/Grid2D.html#upy(int, int)">upy</a></strong>(int&nbsp;x,
   int&nbsp;y)</code>
<div class="block">Hex up y.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>int</code></td>
<td class="colLast"><code><strong><a href="../../../sim/field/grid/Grid2D.html#urx(int, int)">urx</a></strong>(int&nbsp;x,
   int&nbsp;y)</code>
<div class="block">Hex upright x.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>int</code></td>
<td class="colLast"><code><strong><a href="../../../sim/field/grid/Grid2D.html#ury(int, int)">ury</a></strong>(int&nbsp;x,
   int&nbsp;y)</code>
<div class="block">Hex upright y.</div>
</td>
</tr>
</table>
</li>
</ul>
</li>
</ul>
</div>
<div class="details">
<ul class="blockList">
<li class="blockList">
<!-- ============ FIELD DETAIL =========== -->
<ul class="blockList">
<li class="blockList"><a name="field_detail">
<!--   -->
</a>
<h3>Field Detail</h3>
<a name="BOUNDED">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>BOUNDED</h4>
<pre>static final&nbsp;int BOUNDED</pre>
<div class="block">Bounded Mode for neighborhood lookup.  Indicates that the Grid2D in question
        is being used in a way that assumes that it 
        has no valid locations outside of the rectangle starting at (0,0) and
        ending at (width-1, height-1) inclusive.</div>
<dl><dt><span class="strong">See Also:</span></dt><dd><a href="../../../constant-values.html#sim.field.grid.Grid2D.BOUNDED">Constant Field Values</a></dd></dl>
</li>
</ul>
<a name="UNBOUNDED">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>UNBOUNDED</h4>
<pre>static final&nbsp;int UNBOUNDED</pre>
<div class="block">Bounded Mode for neighborhood lookup.  Indicates that the Grid2D in question
        is being used in a way that assumes that any numerical location is a valid
        location.  Note that Grid2D subclasses based on arrays, such as DoubleGrid2D,
        IntGrid2D, ObjectGrid2D, and DenseGrid2D, <b>cannot be used</b> in an unbounded
        fashion.</div>
<dl><dt><span class="strong">See Also:</span></dt><dd><a href="../../../constant-values.html#sim.field.grid.Grid2D.UNBOUNDED">Constant Field Values</a></dd></dl>
</li>
</ul>
<a name="TOROIDAL">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>TOROIDAL</h4>
<pre>static final&nbsp;int TOROIDAL</pre>
<div class="block">Bounded Mode for toroidal lookup.  Indicates that the Grid2D in question
        is being used in a way that assumes that it is bounded, but wrap-around: for
        example, (0,0) is located one away diagonally from (width-1, height-1).</div>
<dl><dt><span class="strong">See Also:</span></dt><dd><a href="../../../constant-values.html#sim.field.grid.Grid2D.TOROIDAL">Constant Field Values</a></dd></dl>
</li>
</ul>
<a name="CENTER">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>CENTER</h4>
<pre>static final&nbsp;int CENTER</pre>
<div class="block">Center measurement rule for raidal neighborhood lookup.  Indicates that
        radial lookup will include locations whose grid cell centers overlap with 
        the neighborhood region.</div>
<dl><dt><span class="strong">See Also:</span></dt><dd><a href="../../../constant-values.html#sim.field.grid.Grid2D.CENTER">Constant Field Values</a></dd></dl>
</li>
</ul>
<a name="ALL">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>ALL</h4>
<pre>static final&nbsp;int ALL</pre>
<div class="block">"All" measurement rule for raidal neighborhood lookup.  Indicates that
        radial lookup will include locations whose grid cells are entirely within 
        the neighborhood region.</div>
<dl><dt><span class="strong">See Also:</span></dt><dd><a href="../../../constant-values.html#sim.field.grid.Grid2D.ALL">Constant Field Values</a></dd></dl>
</li>
</ul>
<a name="ANY">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>ANY</h4>
<pre>static final&nbsp;int ANY</pre>
<div class="block">"Any" measurement rule for raidal neighborhood lookup.  Indicates that
        radial lookup will include locations whose grid cells have any overlap
        at all with the neighborhood region.</div>
<dl><dt><span class="strong">See Also:</span></dt><dd><a href="../../../constant-values.html#sim.field.grid.Grid2D.ANY">Constant Field Values</a></dd></dl>
</li>
</ul>
<a name="ANY_SIZE">
<!--   -->
</a>
<ul class="blockListLast">
<li class="blockList">
<h4>ANY_SIZE</h4>
<pre>static final&nbsp;int ANY_SIZE</pre>
<div class="block">Pass this into buildMap to indicate that it should make a map of any size it likes.</div>
<dl><dt><span class="strong">See Also:</span></dt><dd><a href="../../../constant-values.html#sim.field.grid.Grid2D.ANY_SIZE">Constant Field Values</a></dd></dl>
</li>
</ul>
</li>
</ul>
<!-- ============ METHOD DETAIL ========== -->
<ul class="blockList">
<li class="blockList"><a name="method_detail">
<!--   -->
</a>
<h3>Method Detail</h3>
<a name="getWidth()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getWidth</h4>
<pre>int&nbsp;getWidth()</pre>
<div class="block">Returns the width of the field.</div>
</li>
</ul>
<a name="getHeight()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getHeight</h4>
<pre>int&nbsp;getHeight()</pre>
<div class="block">Returns the width of the field.</div>
</li>
</ul>
<a name="tx(int)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>tx</h4>
<pre>int&nbsp;tx(int&nbsp;x)</pre>
<div class="block">Toroidal x. The following definition:<br><br>
        final int length = this.length; <br>
        if (z >= 0) return (z % length); <br>
        final int length2 = (z % length) + length;<br>
        if (length2 &lt; length) return length2;<br>
        return 0;<br><br>
        ... produces the correct code and is 27 bytes, so it's likely to be inlined in Hotspot for 1.4.1.</div>
</li>
</ul>
<a name="ty(int)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>ty</h4>
<pre>int&nbsp;ty(int&nbsp;y)</pre>
<div class="block">Toroidal y.  The following definition:<br><br>
        final int length = this.length;  <br>
        if (z >= 0) return (z % length);  <br>
        final int length2 = (z % length) + length; <br>
        if (length2 < length) return length2; <br>
        return 0; <br><br>
        ... produces the correct code and is 27 bytes, so it's likely to be inlined in Hotspot for 1.4.1.</div>
</li>
</ul>
<a name="stx(int)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>stx</h4>
<pre>int&nbsp;stx(int&nbsp;x)</pre>
<div class="block">Simple [and fast] toroidal x.  Use this if the values you'd pass in never stray
        beyond (-width ... width * 2) not inclusive.  It's a bit faster than the full
        toroidal computation as it uses if statements rather than two modulos.
        The following definition:<br>
        { int width = this.width; if (x >= 0) { if (x < width) return x; return x - width; } return x + width; }
        ...produces the shortest code (24 bytes) and is inlined in Hotspot for 1.4.1.  However
        in most cases removing the int width = this.width; is likely to be a little faster if most
        objects are usually within the toroidal region.</div>
</li>
</ul>
<a name="sty(int)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>sty</h4>
<pre>int&nbsp;sty(int&nbsp;y)</pre>
<div class="block">Simple [and fast] toroidal y.  Use this if the values you'd pass in never stray
        beyond (-height ... height * 2) not inclusive.  It's a bit faster than the full
        toroidal computation as it uses if statements rather than two modulos.
        The following definition:<br>
        { int height = this.height; if (y >= 0) { if (y < height) return y ; return y - height; } return y + height; }
        ...produces the shortest code (24 bytes) and is inlined in Hotspot for 1.4.1. However
        in most cases removing the int height = this.height; is likely to be a little faster if most
        objects are usually within the toroidal region.</div>
</li>
</ul>
<a name="ulx(int, int)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>ulx</h4>
<pre>int&nbsp;ulx(int&nbsp;x,
      int&nbsp;y)</pre>
<div class="block">Hex upleft x.</div>
</li>
</ul>
<a name="uly(int, int)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>uly</h4>
<pre>int&nbsp;uly(int&nbsp;x,
      int&nbsp;y)</pre>
<div class="block">Hex upleft y.</div>
</li>
</ul>
<a name="urx(int, int)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>urx</h4>
<pre>int&nbsp;urx(int&nbsp;x,
      int&nbsp;y)</pre>
<div class="block">Hex upright x.</div>
</li>
</ul>
<a name="ury(int, int)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>ury</h4>
<pre>int&nbsp;ury(int&nbsp;x,
      int&nbsp;y)</pre>
<div class="block">Hex upright y.</div>
</li>
</ul>
<a name="dlx(int, int)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>dlx</h4>
<pre>int&nbsp;dlx(int&nbsp;x,
      int&nbsp;y)</pre>
<div class="block">Hex downleft x.</div>
</li>
</ul>
<a name="dly(int, int)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>dly</h4>
<pre>int&nbsp;dly(int&nbsp;x,
      int&nbsp;y)</pre>
<div class="block">Hex downleft y.</div>
</li>
</ul>
<a name="drx(int, int)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>drx</h4>
<pre>int&nbsp;drx(int&nbsp;x,
      int&nbsp;y)</pre>
<div class="block">Hex downright x.</div>
</li>
</ul>
<a name="dry(int, int)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>dry</h4>
<pre>int&nbsp;dry(int&nbsp;x,
      int&nbsp;y)</pre>
<div class="block">Hex downright y.</div>
</li>
</ul>
<a name="upx(int, int)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>upx</h4>
<pre>int&nbsp;upx(int&nbsp;x,
      int&nbsp;y)</pre>
<div class="block">Hex up x.</div>
</li>
</ul>
<a name="upy(int, int)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>upy</h4>
<pre>int&nbsp;upy(int&nbsp;x,
      int&nbsp;y)</pre>
<div class="block">Hex up y.</div>
</li>
</ul>
<a name="downx(int, int)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>downx</h4>
<pre>int&nbsp;downx(int&nbsp;x,
        int&nbsp;y)</pre>
<div class="block">Hex down x.</div>
</li>
</ul>
<a name="downy(int, int)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>downy</h4>
<pre>int&nbsp;downy(int&nbsp;x,
        int&nbsp;y)</pre>
<div class="block">Hex down y.</div>
</li>
</ul>
<a name="trb(int, int)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>trb</h4>
<pre>boolean&nbsp;trb(int&nbsp;x,
          int&nbsp;y)</pre>
<div class="block">Horizontal edge is on the bottom for triangle.  True if x + y is odd.
        One definition of this is <tt>return ((x + y) & 1) == 1;</tt></div>
</li>
</ul>
<a name="trt(int, int)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>trt</h4>
<pre>boolean&nbsp;trt(int&nbsp;x,
          int&nbsp;y)</pre>
<div class="block">Horizontal edge is on the top for triangle.  True if x + y is even.
        One definition of this is <tt>return ((x + y) & 1) == 0;</tt></div>
</li>
</ul>
<a name="getNeighborsMaxDistance(int, int, int, boolean, sim.util.IntBag, sim.util.IntBag)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getNeighborsMaxDistance</h4>
<pre>void&nbsp;getNeighborsMaxDistance(int&nbsp;x,
                           int&nbsp;y,
                           int&nbsp;dist,
                           boolean&nbsp;toroidal,
                           <a href="../../../sim/util/IntBag.html" title="class in sim.util">IntBag</a>&nbsp;xPos,
                           <a href="../../../sim/util/IntBag.html" title="class in sim.util">IntBag</a>&nbsp;yPos)</pre>
<div class="block"><span class="strong">Deprecated.</span>&nbsp;<i></i></div>
<div class="block">Gets all neighbors of a location that satisfy max( abs(x-X) , abs(y-Y) ) <= dist.  This region forms a
 square 2*dist+1 cells across, centered at (X,Y).  If dist==1, this
 is equivalent to the so-called "Moore Neighborhood" (the eight neighbors surrounding (X,Y)), plus (X,Y) itself.
 Places each x and y value of these locations in the provided IntBags xPos and yPos, clearing the bags first.

 <p> This function may only run in two modes: toroidal or bounded.  Unbounded lookup is not permitted, and so
 this function is deprecated: instead you should use the other version of this function which has more functionality.
 If "bounded",
 then the neighbors are restricted to be only those which lie within the box ranging from (0,0) to (width, height), 
 that is, the width and height of the grid.   if "toroidal",
 then the environment is assumed to be toroidal, that is, wrap-around, and neighbors are computed in this fashion.  Toroidal
 locations will not appear multiple times: specifically, if the neighborhood distance is so large that it wraps completely around
 the width or height of the box, neighbors will not be counted multiple times.  Note that to ensure this, subclasses may need to
 resort to expensive duplicate removal, so it's not suggested you use so unreasonably large distances.

 <p>The origin -- that is, the (x,y) point at the center of the neighborhood -- is always included in the results.

 <p>This function is equivalent to: <tt>getNeighborsMaxDistance(x,y,dist,toroidal ? Grid2D.TOROIDAL : Grid2D.BOUNDED, true, xPos, yPos);</tt></div>
</li>
</ul>
<a name="getMooreLocations(int, int, int, int, boolean, sim.util.IntBag, sim.util.IntBag)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getMooreLocations</h4>
<pre>void&nbsp;getMooreLocations(int&nbsp;x,
                     int&nbsp;y,
                     int&nbsp;dist,
                     int&nbsp;mode,
                     boolean&nbsp;includeOrigin,
                     <a href="../../../sim/util/IntBag.html" title="class in sim.util">IntBag</a>&nbsp;xPos,
                     <a href="../../../sim/util/IntBag.html" title="class in sim.util">IntBag</a>&nbsp;yPos)</pre>
<div class="block">Gets all neighbors of a location that satisfy max( abs(x-X) , abs(y-Y) ) <= dist.  This region forms a
 square 2*dist+1 cells across, centered at (X,Y).  If dist==1, this
 is equivalent to the so-called "Moore Neighborhood" (the eight neighbors surrounding (X,Y)), plus (X,Y) itself.
 Places each x and y value of these locations in the provided IntBags xPos and yPos, clearing the bags first.

 <p>This function may be run in one of three modes: Grid2D.BOUNDED, Grid2D.UNBOUNDED, and Grid2D.TOROIDAL.  If "bounded",
 then the neighbors are restricted to be only those which lie within the box ranging from (0,0) to (width, height), 
 that is, the width and height of the grid.  If "unbounded", then the neighbors are not so restricted.  Note that unbounded
 neighborhood lookup only makes sense if your grid allows locations to actually <i>be</i> outside this box.  For example,
 SparseGrid2D permits this but ObjectGrid2D and DoubleGrid2D and IntGrid2D and DenseGrid2D do not.  Finally if "toroidal",
 then the environment is assumed to be toroidal, that is, wrap-around, and neighbors are computed in this fashion.  Toroidal
 locations will not appear multiple times: specifically, if the neighborhood distance is so large that it wraps completely around
 the width or height of the box, neighbors will not be counted multiple times.  Note that to ensure this, subclasses may need to
 resort to expensive duplicate removal, so it's not suggested you use so unreasonably large distances.

 <p>You can also opt to include the origin -- that is, the (x,y) point at the center of the neighborhood -- in the neighborhood results.</div>
</li>
</ul>
<a name="getNeighborsHamiltonianDistance(int, int, int, boolean, sim.util.IntBag, sim.util.IntBag)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getNeighborsHamiltonianDistance</h4>
<pre>void&nbsp;getNeighborsHamiltonianDistance(int&nbsp;x,
                                   int&nbsp;y,
                                   int&nbsp;dist,
                                   boolean&nbsp;toroidal,
                                   <a href="../../../sim/util/IntBag.html" title="class in sim.util">IntBag</a>&nbsp;xPos,
                                   <a href="../../../sim/util/IntBag.html" title="class in sim.util">IntBag</a>&nbsp;yPos)</pre>
<div class="block"><span class="strong">Deprecated.</span>&nbsp;<i></i></div>
<div class="block">Gets all neighbors of a location that satisfy abs(x-X) + abs(y-Y) <= dist.  This region forms a diamond
 2*dist+1 cells from point to opposite point inclusive, centered at (X,Y).  If dist==1 this is
 equivalent to the so-called "Von-Neumann Neighborhood" (the four neighbors above, below, left, and right of (X,Y)),
 plus (X,Y) itself.
 Places each x and y value of these locations in the provided IntBags xPos and yPos, clearing the bags first.

 <p> This function may only run in two modes: toroidal or bounded.  Unbounded lookup is not permitted, and so
 this function is deprecated: instead you should use the other version of this function which has more functionality.
 If "bounded",
 then the neighbors are restricted to be only those which lie within the box ranging from (0,0) to (width, height), 
 that is, the width and height of the grid.   if "toroidal",
 then the environment is assumed to be toroidal, that is, wrap-around, and neighbors are computed in this fashion.  Toroidal
 locations will not appear multiple times: specifically, if the neighborhood distance is so large that it wraps completely around
 the width or height of the box, neighbors will not be counted multiple times.  Note that to ensure this, subclasses may need to
 resort to expensive duplicate removal, so it's not suggested you use so unreasonably large distances.

 <p>The origin -- that is, the (x,y) point at the center of the neighborhood -- is always included in the results.

 <p>This function is equivalent to: <tt>getNeighborsHamiltonianDistance(x,y,dist,toroidal ? Grid2D.TOROIDAL : Grid2D.BOUNDED, true, xPos, yPos);</tt></div>
</li>
</ul>
<a name="getVonNeumannLocations(int, int, int, int, boolean, sim.util.IntBag, sim.util.IntBag)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getVonNeumannLocations</h4>
<pre>void&nbsp;getVonNeumannLocations(int&nbsp;x,
                          int&nbsp;y,
                          int&nbsp;dist,
                          int&nbsp;mode,
                          boolean&nbsp;includeOrigin,
                          <a href="../../../sim/util/IntBag.html" title="class in sim.util">IntBag</a>&nbsp;xPos,
                          <a href="../../../sim/util/IntBag.html" title="class in sim.util">IntBag</a>&nbsp;yPos)</pre>
<div class="block">Gets all neighbors of a location that satisfy abs(x-X) + abs(y-Y) <= dist.  This region forms a diamond
 2*dist+1 cells from point to opposite point inclusive, centered at (X,Y).  If dist==1 this is
 equivalent to the so-called "Von-Neumann Neighborhood" (the four neighbors above, below, left, and right of (X,Y)),
 plus (X,Y) itself.
 Places each x and y value of these locations in the provided IntBags xPos and yPos, clearing the bags first.

 <p>This function may be run in one of three modes: Grid2D.BOUNDED, Grid2D.UNBOUNDED, and Grid2D.TOROIDAL.  If "bounded",
 then the neighbors are restricted to be only those which lie within the box ranging from (0,0) to (width, height), 
 that is, the width and height of the grid.  If "unbounded", then the neighbors are not so restricted.  Note that unbounded
 neighborhood lookup only makes sense if your grid allows locations to actually <i>be</i> outside this box.  For example,
 SparseGrid2D permits this but ObjectGrid2D and DoubleGrid2D and IntGrid2D and DenseGrid2D do not.  Finally if "toroidal",
 then the environment is assumed to be toroidal, that is, wrap-around, and neighbors are computed in this fashion.  Toroidal
 locations will not appear multiple times: specifically, if the neighborhood distance is so large that it wraps completely around
 the width or height of the box, neighbors will not be counted multiple times.  Note that to ensure this, subclasses may need to
 resort to expensive duplicate removal, so it's not suggested you use so unreasonably large distances.

 <p>You can also opt to include the origin -- that is, the (x,y) point at the center of the neighborhood -- in the neighborhood results.</div>
</li>
</ul>
<a name="getNeighborsHexagonalDistance(int, int, int, boolean, sim.util.IntBag, sim.util.IntBag)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getNeighborsHexagonalDistance</h4>
<pre>void&nbsp;getNeighborsHexagonalDistance(int&nbsp;x,
                                 int&nbsp;y,
                                 int&nbsp;dist,
                                 boolean&nbsp;toroidal,
                                 <a href="../../../sim/util/IntBag.html" title="class in sim.util">IntBag</a>&nbsp;xPos,
                                 <a href="../../../sim/util/IntBag.html" title="class in sim.util">IntBag</a>&nbsp;yPos)</pre>
<div class="block"><span class="strong">Deprecated.</span>&nbsp;<i></i></div>
<div class="block">Gets all neighbors located within the hexagon centered at (X,Y) and 2*dist+1 cells from point to opposite point 
 inclusive.
 If dist==1, this is equivalent to the six neighbors immediately surrounding (X,Y), 
 plus (X,Y) itself.
 Places each x and y value of these locations in the provided IntBags xPos and yPos, clearing the bags first.

 <p> This function may only run in two modes: toroidal or bounded.  Unbounded lookup is not permitted, and so
 this function is deprecated: instead you should use the other version of this function which has more functionality.
 If "bounded",
 then the neighbors are restricted to be only those which lie within the box ranging from (0,0) to (width, height), 
 that is, the width and height of the grid.   if "toroidal",
 then the environment is assumed to be toroidal, that is, wrap-around, and neighbors are computed in this fashion.  Toroidal
 locations will not appear multiple times: specifically, if the neighborhood distance is so large that it wraps completely around
 the width or height of the box, neighbors will not be counted multiple times.  Note that to ensure this, subclasses may need to
 resort to expensive duplicate removal, so it's not suggested you use so unreasonably large distances.

 <p>The origin -- that is, the (x,y) point at the center of the neighborhood -- is always included in the results.

 <p>This function is equivalent to: <tt>getNeighborsHexagonalDistance(x,y,dist,toroidal ? Grid2D.TOROIDAL : Grid2D.BOUNDED, true, xPos, yPos);</tt></div>
</li>
</ul>
<a name="getHexagonalLocations(int, int, int, int, boolean, sim.util.IntBag, sim.util.IntBag)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getHexagonalLocations</h4>
<pre>void&nbsp;getHexagonalLocations(int&nbsp;x,
                         int&nbsp;y,
                         int&nbsp;dist,
                         int&nbsp;mode,
                         boolean&nbsp;includeOrigin,
                         <a href="../../../sim/util/IntBag.html" title="class in sim.util">IntBag</a>&nbsp;xPos,
                         <a href="../../../sim/util/IntBag.html" title="class in sim.util">IntBag</a>&nbsp;yPos)</pre>
<div class="block">Gets all neighbors located within the hexagon centered at (X,Y) and 2*dist+1 cells from point to opposite point 
 inclusive.
 If dist==1, this is equivalent to the six neighbors immediately surrounding (X,Y), 
 plus (X,Y) itself.
 Places each x and y value of these locations in the provided IntBags xPos and yPos, clearing the bags first.

 <p>This function may be run in one of three modes: Grid2D.BOUNDED, Grid2D.UNBOUNDED, and Grid2D.TOROIDAL.  If "bounded",
 then the neighbors are restricted to be only those which lie within the box ranging from (0,0) to (width, height), 
 that is, the width and height of the grid.  If "unbounded", then the neighbors are not so restricted.  Note that unbounded
 neighborhood lookup only makes sense if your grid allows locations to actually <i>be</i> outside this box.  For example,
 SparseGrid2D permits this but ObjectGrid2D and DoubleGrid2D and IntGrid2D and DenseGrid2D do not.  Finally if "toroidal",
 then the environment is assumed to be toroidal, that is, wrap-around, and neighbors are computed in this fashion.  Toroidal
 locations will not appear multiple times: specifically, if the neighborhood distance is so large that it wraps completely around
 the width or height of the box, neighbors will not be counted multiple times.  Note that to ensure this, subclasses may need to
 resort to expensive duplicate removal, so it's not suggested you use so unreasonably large distances.

 <p>You can also opt to include the origin -- that is, the (x,y) point at the center of the neighborhood -- in the neighborhood results.</div>
</li>
</ul>
<a name="getRadialLocations(int, int, double, int, boolean, sim.util.IntBag, sim.util.IntBag)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getRadialLocations</h4>
<pre>void&nbsp;getRadialLocations(int&nbsp;x,
                      int&nbsp;y,
                      double&nbsp;dist,
                      int&nbsp;mode,
                      boolean&nbsp;includeOrigin,
                      <a href="../../../sim/util/IntBag.html" title="class in sim.util">IntBag</a>&nbsp;xPos,
                      <a href="../../../sim/util/IntBag.html" title="class in sim.util">IntBag</a>&nbsp;yPos)</pre>
<div class="block">Gets all neighbors overlapping with a circular region centered at (X,Y) and with a radius of dist.
 The measurement rule is Grid2D.ANY, meaning those cells which overlap at all with the region.  
 The region is closed, meaning that that points which touch on the outer surface of the circle will be 
 considered members of the region.

 <p>Places each x and y value of these locations in the provided IntBags xPos and yPos, clearing the bags first.

 <p>This function may be run in one of three modes: Grid2D.BOUNDED, Grid2D.UNBOUNDED, and Grid2D.TOROIDAL.  If "bounded",
 then the neighbors are restricted to be only those which lie within the box ranging from (0,0) to (width, height), 
 that is, the width and height of the grid.  If "unbounded", then the neighbors are not so restricted.  Note that unbounded
 neighborhood lookup only makes sense if your grid allows locations to actually <i>be</i> outside this box.  For example,
 SparseGrid2D permits this but ObjectGrid2D and DoubleGrid2D and IntGrid2D and DenseGrid2D do not.  Finally if "toroidal",
 then the environment is assumed to be toroidal, that is, wrap-around, and neighbors are computed in this fashion.  Toroidal
 locations will not appear multiple times: specifically, if the neighborhood distance is so large that it wraps completely around
 the width or height of the box, neighbors will not be counted multiple times.  Note that to ensure this, subclasses may need to
 resort to expensive duplicate removal, so it's not suggested you use so unreasonably large distances.

 <p>You can also opt to include the origin -- that is, the (x,y) point at the center of the neighborhood -- in the neighborhood results.</div>
</li>
</ul>
<a name="getRadialLocations(int, int, double, int, boolean, int, boolean, sim.util.IntBag, sim.util.IntBag)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getRadialLocations</h4>
<pre>void&nbsp;getRadialLocations(int&nbsp;x,
                      int&nbsp;y,
                      double&nbsp;dist,
                      int&nbsp;mode,
                      boolean&nbsp;includeOrigin,
                      int&nbsp;measurementRule,
                      boolean&nbsp;closed,
                      <a href="../../../sim/util/IntBag.html" title="class in sim.util">IntBag</a>&nbsp;xPos,
                      <a href="../../../sim/util/IntBag.html" title="class in sim.util">IntBag</a>&nbsp;yPos)</pre>
<div class="block">Gets all neighbors overlapping with a circular region centered at (X,Y) and with a radius of dist.
 If measurementRule is Grid2D.CENTER, then the measurement rule will be those cells whose centers
 overlap with the region.  If measurementRule is Grid2D.ALL, then the measurement rule will be those
 cells which entirely overlap with the region.  If measurementrule is Grid2D.ANY, then the measurement
 rule will be those cells which overlap at all with the region.  If closed is true, then the region will
 be considered "closed", that is, that points which touch on the outer surface of the circle will be 
 considered members of the region.  If closed is open, then the region will be considered "open", that is,
 that points which touch on the outer surface of the circle will NOT be considered members of the region.

 <p>Places each x and y value of these locations in the provided IntBags xPos and yPos, clearing the bags first.

 <p>This function may be run in one of three modes: Grid2D.BOUNDED, Grid2D.UNBOUNDED, and Grid2D.TOROIDAL.  If "bounded",
 then the neighbors are restricted to be only those which lie within the box ranging from (0,0) to (width, height), 
 that is, the width and height of the grid.  If "unbounded", then the neighbors are not so restricted.  Note that unbounded
 neighborhood lookup only makes sense if your grid allows locations to actually <i>be</i> outside this box.  For example,
 SparseGrid2D permits this but ObjectGrid2D and DoubleGrid2D and IntGrid2D and DenseGrid2D do not.  Finally if "toroidal",
 then the environment is assumed to be toroidal, that is, wrap-around, and neighbors are computed in this fashion.  Toroidal
 locations will not appear multiple times: specifically, if the neighborhood distance is so large that it wraps completely around
 the width or height of the box, neighbors will not be counted multiple times.  Note that to ensure this, subclasses may need to
 resort to expensive duplicate removal, so it's not suggested you use so unreasonably large distances.

 <p>You can also opt to include the origin -- that is, the (x,y) point at the center of the neighborhood -- in the neighborhood results.</div>
</li>
</ul>
<a name="buildMap(java.util.Map)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>buildMap</h4>
<pre>java.util.Map&nbsp;buildMap(java.util.Map&nbsp;other)</pre>
<div class="block">Creates a Map which is a copy of another. By default, HashMap is used.</div>
</li>
</ul>
<a name="buildMap(int)">
<!--   -->
</a>
<ul class="blockListLast">
<li class="blockList">
<h4>buildMap</h4>
<pre>java.util.Map&nbsp;buildMap(int&nbsp;size)</pre>
<div class="block">Creates a map of the provided size (or any size it likes if ANY_SIZE is passed in).  By default, HashMap is used.</div>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
</div>
<!-- ========= END OF CLASS DATA ========= -->
<!-- ======= START OF BOTTOM NAVBAR ====== -->
<div class="bottomNav"><a name="navbar_bottom">
<!--   -->
</a><a href="#skip-navbar_bottom" title="Skip navigation links"></a><a name="navbar_bottom_firstrow">
<!--   -->
</a>
<ul class="navList" title="Navigation">
<li><a href="../../../overview-summary.html">Overview</a></li>
<li><a href="package-summary.html">Package</a></li>
<li class="navBarCell1Rev">Class</li>
<li><a href="package-tree.html">Tree</a></li>
<li><a href="../../../deprecated-list.html">Deprecated</a></li>
<li><a href="../../../index-all.html">Index</a></li>
<li><a href="../../../help-doc.html">Help</a></li>
</ul>
</div>
<div class="subNav">
<ul class="navList">
<li><a href="../../../sim/field/grid/DoubleGrid3D.html" title="class in sim.field.grid"><span class="strong">Prev Class</span></a></li>
<li><a href="../../../sim/field/grid/Grid3D.html" title="interface in sim.field.grid"><span class="strong">Next Class</span></a></li>
</ul>
<ul class="navList">
<li><a href="../../../index.html?sim/field/grid/Grid2D.html" target="_top">Frames</a></li>
<li><a href="Grid2D.html" target="_top">No Frames</a></li>
</ul>
<ul class="navList" id="allclasses_navbar_bottom">
<li><a href="../../../allclasses-noframe.html">All Classes</a></li>
</ul>
<div>
<script type="text/javascript"><!--
  allClassesLink = document.getElementById("allclasses_navbar_bottom");
  if(window==top) {
    allClassesLink.style.display = "block";
  }
  else {
    allClassesLink.style.display = "none";
  }
  //-->
</script>
</div>
<div>
<ul class="subNavList">
<li>Summary:&nbsp;</li>
<li>Nested&nbsp;|&nbsp;</li>
<li><a href="#field_summary">Field</a>&nbsp;|&nbsp;</li>
<li>Constr&nbsp;|&nbsp;</li>
<li><a href="#method_summary">Method</a></li>
</ul>
<ul class="subNavList">
<li>Detail:&nbsp;</li>
<li><a href="#field_detail">Field</a>&nbsp;|&nbsp;</li>
<li>Constr&nbsp;|&nbsp;</li>
<li><a href="#method_detail">Method</a></li>
</ul>
</div>
<a name="skip-navbar_bottom">
<!--   -->
</a></div>
<!-- ======== END OF BOTTOM NAVBAR ======= -->
</body>
</html>
