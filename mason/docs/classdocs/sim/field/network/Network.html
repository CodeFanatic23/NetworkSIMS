<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!-- NewPage -->
<html lang="en">
<head>
<!-- Generated by javadoc (version 1.7.0_51) on Fri Jun 19 12:12:04 EDT 2015 -->
<title>Network</title>
<meta name="date" content="2015-06-19">
<link rel="stylesheet" type="text/css" href="../../../stylesheet.css" title="Style">
</head>
<body>
<script type="text/javascript"><!--
    if (location.href.indexOf('is-external=true') == -1) {
        parent.document.title="Network";
    }
//-->
</script>
<noscript>
<div>JavaScript is disabled on your browser.</div>
</noscript>
<!-- ========= START OF TOP NAVBAR ======= -->
<div class="topNav"><a name="navbar_top">
<!--   -->
</a><a href="#skip-navbar_top" title="Skip navigation links"></a><a name="navbar_top_firstrow">
<!--   -->
</a>
<ul class="navList" title="Navigation">
<li><a href="../../../overview-summary.html">Overview</a></li>
<li><a href="package-summary.html">Package</a></li>
<li class="navBarCell1Rev">Class</li>
<li><a href="package-tree.html">Tree</a></li>
<li><a href="../../../deprecated-list.html">Deprecated</a></li>
<li><a href="../../../index-all.html">Index</a></li>
<li><a href="../../../help-doc.html">Help</a></li>
</ul>
</div>
<div class="subNav">
<ul class="navList">
<li><a href="../../../sim/field/network/Edge.html" title="class in sim.field.network"><span class="strong">Prev Class</span></a></li>
<li><a href="../../../sim/field/network/Network.IndexOutIn.html" title="class in sim.field.network"><span class="strong">Next Class</span></a></li>
</ul>
<ul class="navList">
<li><a href="../../../index.html?sim/field/network/Network.html" target="_top">Frames</a></li>
<li><a href="Network.html" target="_top">No Frames</a></li>
</ul>
<ul class="navList" id="allclasses_navbar_top">
<li><a href="../../../allclasses-noframe.html">All Classes</a></li>
</ul>
<div>
<script type="text/javascript"><!--
  allClassesLink = document.getElementById("allclasses_navbar_top");
  if(window==top) {
    allClassesLink.style.display = "block";
  }
  else {
    allClassesLink.style.display = "none";
  }
  //-->
</script>
</div>
<div>
<ul class="subNavList">
<li>Summary:&nbsp;</li>
<li><a href="#nested_class_summary">Nested</a>&nbsp;|&nbsp;</li>
<li><a href="#field_summary">Field</a>&nbsp;|&nbsp;</li>
<li><a href="#constructor_summary">Constr</a>&nbsp;|&nbsp;</li>
<li><a href="#method_summary">Method</a></li>
</ul>
<ul class="subNavList">
<li>Detail:&nbsp;</li>
<li><a href="#field_detail">Field</a>&nbsp;|&nbsp;</li>
<li><a href="#constructor_detail">Constr</a>&nbsp;|&nbsp;</li>
<li><a href="#method_detail">Method</a></li>
</ul>
</div>
<a name="skip-navbar_top">
<!--   -->
</a></div>
<!-- ========= END OF TOP NAVBAR ========= -->
<!-- ======== START OF CLASS DATA ======== -->
<div class="header">
<div class="subTitle">sim.field.network</div>
<h2 title="Class Network" class="title">Class Network</h2>
</div>
<div class="contentContainer">
<ul class="inheritance">
<li>java.lang.Object</li>
<li>
<ul class="inheritance">
<li>sim.field.network.Network</li>
</ul>
</li>
</ul>
<div class="description">
<ul class="blockList">
<li class="blockList">
<dl>
<dt>All Implemented Interfaces:</dt>
<dd>java.io.Serializable</dd>
</dl>
<hr>
<br>
<pre>public class <span class="strong">Network</span>
extends java.lang.Object
implements java.io.Serializable</pre>
<div class="block">The Network is a field which stores binary graph and multigraph structures of all kinds, using hash tables to allow
    reasonably rapid dynamic modification.

    <p>The nodes of a Network's graph can be any arbitrary, properly hashable object.  The edges of the
    graph are members of the Edge class.  This class is little more than a wrapper around an arbitrary object as well (the Edge's 'info'
    object).  Thus your graph's nodes and edges can essentially be objects entirely of your choosing.

    <p>Edge objects also contain pointers to the Nodes that they are to and from (plus some auxillary index information
    for speed).

    <p>Nodes and Edges are stored in the Network using two data structures: a Bag containing all the nodes in the Field;
    and a Map which maps each Node to a container holding the Node's index (position) in the Bag, plus a Bag of the Node's outgoing
    Edges and a Bag of the Node's incoming Edges.  Ordinarily you won't fool with these structures other than to scan through
    them (in particular, to scan rapidly through the allNodes bag rather than use an iterator).

    <p>To add a node to the Network, simply use addNode(node).  To remove a node, use removeNode(node).
    To add an edge to the Network, use addEdge(fromNode,toNode,edgeInfoObject), where edgeInfoObject is your
    arbitrary edge object. Alternatively, you can make an Edge object from scratch and add it with addEdge(new Edge(fromNode, toNode, edgeInfoObject)).
    You remove edges with removeEdge(edge).  If you add an edge, and its nodes have not been added yet, they will
    automatically be added as well.

    <p>Traversing a Network is easy.  
    To get a Bag of all the incoming (or outgoing) Edges to a node, use getEdgesIn(node) or getEdgesOut(node).
    Do <b>not</b> add or remove Edges from this Bag -- it's used internally and we trust you here.  Also don't expect the
    Bag to not change its values mysteriously later on.  Make a copy of the Bag if you want to keep it and/or modify it.
    Once you have an Edge, you can call its to() method and from() methods to get the nodes it's from and to, and you can
    at any time get and modify its info object.  The to() and from() are fast and inlined.

    <p>However, the getEdgesIn(node) and getEdgesOut(node) methods are not super fast: they require a hash lookup.  If you
    are planning on applying an algorithm on the Network which doesn't change the topology at all but traverses it a lot
    and changes just the <b>contents</b> of the edge info objects and the node object contents, you might consider first 
    getting an adjacency list for the Network with getAdjacencyList(...), or an adjacency matrix with getAdjacencyMatrix(...)
    or getMultigraphAdjacencyMatrix(...).  But remember that as soon as the topology changes (adding/deleting a node or edge),
    the adjacency list is invalid, and you need to request another one.

    <p><b>Computational Complexity.</b>  Adding a node or an edge is O(1).  Removing an edge is O(1).  Removing a node is O(m), where
    m is the total number of edges in and out of the node.  Removing all nodes is O(1) and fast.  Getting the in-edges or out-edges for a node
    is O(1).  Getting the to or from node for an edge is O(1) and fast.

    <p><b>Warning About Hashing.</b>  Java's hashing method is broken in an important way.  One can override the hashCode() and equals()
    methods of an object so that they hash by the value of an object rather than just the pointer to it.  But if this is done, then if
    you use this object as a key in a hash table, then <i>change</i> those values in the object, it will break the hash table -- the key
    and the object hashed by it will both be lost in the hashtable, unable to be accessed or removed from it.  The moral of the story is:
    do not override hashCode() and equals() to hash by value unless your object is <i>immutable</i> -- its values cannot be changed.  This
    is the case, for example, with Strings, which hash by value but cannot be modified.  It's also the case with Int2D, Int3D, Double2D,
    and Double3D, as well as Double, Integer, etc.  Some of Sun's own objects are broken in this respect: Point, Point2D, etc. are both
    mutable <i>and</i> hashed by value.

    <p>This affects you in only one way in a Network: edges are hashed by nodes.  The Network permits you to use any object
    as a node -- but you have been suitably warned: if you use a mutable but hashed-by-value node object, do NOT modify its values while
    it's being used as a key in the Network.

    <p><b>Directed vs. Undirected Graphs.</b>  Networks are constructed to be either directed or undirected, and they cannot be changed
    afterwards without being entirely cleared first (using reset(...)).  If the network is directed, then an Edge's to() and from() nodes 
    have explicit meaning: the Edge goes from() one node to()
    another.  If the network is undirected, then to() and from() are simply the two nodes at each end of the Edge with no special meaning,
    though they're always consistent.  The convenience method <i>edge</i>.getOtherNode(<i>node</i>) will provide "other" node (if node is to(),
    then from() is returned, and vice versa).  This is particularly useful in undirected graphs where you could be entering an edge as to()
    or as from() and you just want to know what the node on the other end of the edge is.

    <p>There are three methods for getting all the edges attached to a node: getEdgesIn(), getEdgesOut(), and the less efficient getEdges().  These methods
    work differently depending on whether or not the network is directed:

    <p><table width="100%" border=0>
    <tr><td><td><b>Directed</b><td><b>Undirected</b>
    <tr><td><b>getEdgesIn()</b><td>Bag&nbsp;of&nbsp;incoming&nbsp;edges<td>Bag&nbsp;of&nbsp;all&nbsp;edges
    <tr><td><b>getEdgesOut()</b><td>Bag&nbsp;of&nbsp;outgoing&nbsp;edges<td>Bag&nbsp;of&nbsp;all&nbsp;edges
    <tr><td><b>getEdges()</b><td><i>Modifiable</i>&nbsp;Bag&nbsp;of&nbsp;all&nbsp;edges<td><i>Modifiable</i>&nbsp;Bag&nbsp;of&nbsp;all&nbsp;edges
    </table>

    <p><b>Hypergraphs.</b> Network is binary.  In the future we may provide a Hypergraph facility if it's needed, but for now you'll
    need to make "multi-edge nodes" and store them in the field, then hook them to your nodes via Edges.  For example, to store the
    relationship foo(node1, node2, node3), here's one way to do it:
    <ol>
    <li>Make a special foo object.
    <li>field.addEdge(foo,node1,new Double(0));
    <li>field.addEdge(foo,node2,new Double(1));
    <li>field.addEdge(foo,node3,new Double(2));
    </ol></div>
<dl><dt><span class="strong">See Also:</span></dt><dd><a href="../../../serialized-form.html#sim.field.network.Network">Serialized Form</a></dd></dl>
</li>
</ul>
</div>
<div class="summary">
<ul class="blockList">
<li class="blockList">
<!-- ======== NESTED CLASS SUMMARY ======== -->
<ul class="blockList">
<li class="blockList"><a name="nested_class_summary">
<!--   -->
</a>
<h3>Nested Class Summary</h3>
<table class="overviewSummary" border="0" cellpadding="3" cellspacing="0" summary="Nested Class Summary table, listing nested classes, and an explanation">
<caption><span>Nested Classes</span><span class="tabEnd">&nbsp;</span></caption>
<tr>
<th class="colFirst" scope="col">Modifier and Type</th>
<th class="colLast" scope="col">Class and Description</th>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static class&nbsp;</code></td>
<td class="colLast"><code><strong><a href="../../../sim/field/network/Network.IndexOutIn.html" title="class in sim.field.network">Network.IndexOutIn</a></strong></code>
<div class="block">The structure stored in the indexOutInHash hash table.</div>
</td>
</tr>
</table>
</li>
</ul>
<!-- =========== FIELD SUMMARY =========== -->
<ul class="blockList">
<li class="blockList"><a name="field_summary">
<!--   -->
</a>
<h3>Field Summary</h3>
<table class="overviewSummary" border="0" cellpadding="3" cellspacing="0" summary="Field Summary table, listing fields, and an explanation">
<caption><span>Fields</span><span class="tabEnd">&nbsp;</span></caption>
<tr>
<th class="colFirst" scope="col">Modifier and Type</th>
<th class="colLast" scope="col">Field and Description</th>
</tr>
<tr class="altColor">
<td class="colFirst"><code><a href="../../../sim/util/Bag.html" title="class in sim.util">Bag</a></code></td>
<td class="colLast"><code><strong><a href="../../../sim/field/network/Network.html#allNodes">allNodes</a></strong></code>
<div class="block">All the objects in the sparse field.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><strong><a href="../../../sim/field/network/Network.html#ANY_SIZE">ANY_SIZE</a></strong></code>
<div class="block">Pass this into buildMap to indicate that it should make a map of any size it likes.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>java.util.Map</code></td>
<td class="colLast"><code><strong><a href="../../../sim/field/network/Network.html#indexOutInHash">indexOutInHash</a></strong></code>
<div class="block">Hashes Network.IndexOutIn structures by Node.</div>
</td>
</tr>
</table>
</li>
</ul>
<!-- ======== CONSTRUCTOR SUMMARY ======== -->
<ul class="blockList">
<li class="blockList"><a name="constructor_summary">
<!--   -->
</a>
<h3>Constructor Summary</h3>
<table class="overviewSummary" border="0" cellpadding="3" cellspacing="0" summary="Constructor Summary table, listing constructors, and an explanation">
<caption><span>Constructors</span><span class="tabEnd">&nbsp;</span></caption>
<tr>
<th class="colOne" scope="col">Constructor and Description</th>
</tr>
<tr class="altColor">
<td class="colOne"><code><strong><a href="../../../sim/field/network/Network.html#Network()">Network</a></strong>()</code>
<div class="block">Constructs a directed graph</div>
</td>
</tr>
<tr class="rowColor">
<td class="colOne"><code><strong><a href="../../../sim/field/network/Network.html#Network(boolean)">Network</a></strong>(boolean&nbsp;directed)</code>
<div class="block">Constructs a directed or undirected graph.</div>
</td>
</tr>
<tr class="altColor">
<td class="colOne"><code><strong><a href="../../../sim/field/network/Network.html#Network(sim.field.network.Network)">Network</a></strong>(<a href="../../../sim/field/network/Network.html" title="class in sim.field.network">Network</a>&nbsp;other)</code>
<div class="block">Constructs copy of an existing graph.</div>
</td>
</tr>
</table>
</li>
</ul>
<!-- ========== METHOD SUMMARY =========== -->
<ul class="blockList">
<li class="blockList"><a name="method_summary">
<!--   -->
</a>
<h3>Method Summary</h3>
<table class="overviewSummary" border="0" cellpadding="3" cellspacing="0" summary="Method Summary table, listing methods, and an explanation">
<caption><span>Methods</span><span class="tabEnd">&nbsp;</span></caption>
<tr>
<th class="colFirst" scope="col">Modifier and Type</th>
<th class="colLast" scope="col">Method and Description</th>
</tr>
<tr class="altColor">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><strong><a href="../../../sim/field/network/Network.html#addEdge(sim.field.network.Edge)">addEdge</a></strong>(<a href="../../../sim/field/network/Edge.html" title="class in sim.field.network">Edge</a>&nbsp;edge)</code>
<div class="block">Add an edge.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><strong><a href="../../../sim/field/network/Network.html#addEdge(java.lang.Object, java.lang.Object, java.lang.Object)">addEdge</a></strong>(java.lang.Object&nbsp;from,
       java.lang.Object&nbsp;to,
       java.lang.Object&nbsp;info)</code>
<div class="block">Add an edge, storing info as the edge's associated information object.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><strong><a href="../../../sim/field/network/Network.html#addNode(java.lang.Object)">addNode</a></strong>(java.lang.Object&nbsp;node)</code>
<div class="block">Add a node</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>java.util.Map</code></td>
<td class="colLast"><code><strong><a href="../../../sim/field/network/Network.html#buildMap(int)">buildMap</a></strong>(int&nbsp;size)</code>
<div class="block">Creates a map of the provided size (or any size it likes if ANY_SIZE is passed in).</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>java.util.Map</code></td>
<td class="colLast"><code><strong><a href="../../../sim/field/network/Network.html#buildMap(java.util.Map)">buildMap</a></strong>(java.util.Map&nbsp;other)</code>
<div class="block">Creates a Map which is a copy of another.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code><a href="../../../sim/util/Bag.html" title="class in sim.util">Bag</a></code></td>
<td class="colLast"><code><strong><a href="../../../sim/field/network/Network.html#clear()">clear</a></strong>()</code>
<div class="block">Removes all nodes, deleting all edges from the Field as well.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code><a href="../../../sim/field/network/Network.html" title="class in sim.field.network">Network</a></code></td>
<td class="colLast"><code><strong><a href="../../../sim/field/network/Network.html#cloneGraph()">cloneGraph</a></strong>()</code>
<div class="block"><strong>Deprecated.</strong>&nbsp;&nbsp;</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code><a href="../../../sim/field/network/Edge.html" title="class in sim.field.network">Edge</a>[][]</code></td>
<td class="colLast"><code><strong><a href="../../../sim/field/network/Network.html#getAdjacencyList(boolean)">getAdjacencyList</a></strong>(boolean&nbsp;outEdges)</code>
<div class="block">Creates and returns an adjacency list.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code><a href="../../../sim/field/network/Edge.html" title="class in sim.field.network">Edge</a>[][]</code></td>
<td class="colLast"><code><strong><a href="../../../sim/field/network/Network.html#getAdjacencyMatrix()">getAdjacencyMatrix</a></strong>()</code>
<div class="block">Creates and returns a simple adjacency matrix, where only one edge between any two nodes is considered -- if you're
        using a multigraph, use getMultigraphAdjacencyMatrix() instead.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code><a href="../../../sim/util/Bag.html" title="class in sim.util">Bag</a></code></td>
<td class="colLast"><code><strong><a href="../../../sim/field/network/Network.html#getAllNodes()">getAllNodes</a></strong>()</code>
<div class="block">Returns all the objects in the Sparse Field.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code><a href="../../../sim/field/network/Edge.html" title="class in sim.field.network">Edge</a></code></td>
<td class="colLast"><code><strong><a href="../../../sim/field/network/Network.html#getEdge(java.lang.Object, java.lang.Object)">getEdge</a></strong>(java.lang.Object&nbsp;from,
       java.lang.Object&nbsp;to)</code>
<div class="block">Returns an arbitrary edge connecting the "from" node to the "to" node, if one exists, else returns null.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code><a href="../../../sim/util/Bag.html" title="class in sim.util">Bag</a></code></td>
<td class="colLast"><code><strong><a href="../../../sim/field/network/Network.html#getEdges(java.lang.Object, sim.util.Bag)">getEdges</a></strong>(java.lang.Object&nbsp;node,
        <a href="../../../sim/util/Bag.html" title="class in sim.util">Bag</a>&nbsp;bag)</code>
<div class="block">Get all the edges that enter or leave a node.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code><a href="../../../sim/util/Bag.html" title="class in sim.util">Bag</a></code></td>
<td class="colLast"><code><strong><a href="../../../sim/field/network/Network.html#getEdges(java.lang.Object, java.lang.Object, sim.util.Bag)">getEdges</a></strong>(java.lang.Object&nbsp;from,
        java.lang.Object&nbsp;to,
        <a href="../../../sim/util/Bag.html" title="class in sim.util">Bag</a>&nbsp;bag)</code>
<div class="block">Clears the provided Bag, then places in it all edges connecting the "from" node to the "to" node.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code><a href="../../../sim/util/Bag.html" title="class in sim.util">Bag</a></code></td>
<td class="colLast"><code><strong><a href="../../../sim/field/network/Network.html#getEdgesIn(java.lang.Object)">getEdgesIn</a></strong>(java.lang.Object&nbsp;node)</code>
<div class="block">Get all edges that enter a node.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code><a href="../../../sim/util/Bag.html" title="class in sim.util">Bag</a></code></td>
<td class="colLast"><code><strong><a href="../../../sim/field/network/Network.html#getEdgesOut(java.lang.Object)">getEdgesOut</a></strong>(java.lang.Object&nbsp;node)</code>
<div class="block">Get all edges that leave a node.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code><a href="../../../sim/field/network/Network.html" title="class in sim.field.network">Network</a></code></td>
<td class="colLast"><code><strong><a href="../../../sim/field/network/Network.html#getGraphComplement(boolean)">getGraphComplement</a></strong>(boolean&nbsp;allowSelfLoops)</code>
<div class="block">Complements the graph: same nodes, no edges where they were, edges where they were not.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code><a href="../../../sim/field/network/Edge.html" title="class in sim.field.network">Edge</a>[][][]</code></td>
<td class="colLast"><code><strong><a href="../../../sim/field/network/Network.html#getMultigraphAdjacencyMatrix()">getMultigraphAdjacencyMatrix</a></strong>()</code>
<div class="block">Creates and returns a multigraph adjacency matrix, which includes all edges from a given node to another -- if you know for sure
        that you have a simple graph (no multiple edges between two nodes), use getAdjacencyMatrix instead.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>int</code></td>
<td class="colLast"><code><strong><a href="../../../sim/field/network/Network.html#getNodeIndex(java.lang.Object)">getNodeIndex</a></strong>(java.lang.Object&nbsp;node)</code>&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><strong><a href="../../../sim/field/network/Network.html#isDirected()">isDirected</a></strong>()</code>&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>java.util.Iterator</code></td>
<td class="colLast"><code><strong><a href="../../../sim/field/network/Network.html#iterator()">iterator</a></strong>()</code>
<div class="block">Iterates over all objects.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><strong><a href="../../../sim/field/network/Network.html#nodeExists(java.lang.Object)">nodeExists</a></strong>(java.lang.Object&nbsp;node)</code>&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><strong><a href="../../../sim/field/network/Network.html#removeAllEdges()">removeAllEdges</a></strong>()</code>
<div class="block">Remove all the edges in the network.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code><a href="../../../sim/util/Bag.html" title="class in sim.util">Bag</a></code></td>
<td class="colLast"><code><strong><a href="../../../sim/field/network/Network.html#removeAllNodes()">removeAllNodes</a></strong>()</code>
<div class="block">Synonym for clear(), here only for backward-compatibility.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code><a href="../../../sim/field/network/Edge.html" title="class in sim.field.network">Edge</a></code></td>
<td class="colLast"><code><strong><a href="../../../sim/field/network/Network.html#removeEdge(sim.field.network.Edge)">removeEdge</a></strong>(<a href="../../../sim/field/network/Edge.html" title="class in sim.field.network">Edge</a>&nbsp;edge)</code>
<div class="block">Removes an edge and returns it.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>java.lang.Object</code></td>
<td class="colLast"><code><strong><a href="../../../sim/field/network/Network.html#removeNode(java.lang.Object)">removeNode</a></strong>(java.lang.Object&nbsp;node)</code>
<div class="block">Removes a node, deleting all incoming and outgoing edges from the Field as well.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><strong><a href="../../../sim/field/network/Network.html#reset(boolean)">reset</a></strong>(boolean&nbsp;directed)</code>
<div class="block">Resets the network, clearing it of nodes and edges.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><strong><a href="../../../sim/field/network/Network.html#reverseAllEdges()">reverseAllEdges</a></strong>()</code>
<div class="block">This reverse the direction of all edges in the graph.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code><a href="../../../sim/field/network/Edge.html" title="class in sim.field.network">Edge</a></code></td>
<td class="colLast"><code><strong><a href="../../../sim/field/network/Network.html#updateEdge(sim.field.network.Edge, java.lang.Object, java.lang.Object, java.lang.Object)">updateEdge</a></strong>(<a href="../../../sim/field/network/Edge.html" title="class in sim.field.network">Edge</a>&nbsp;edge,
          java.lang.Object&nbsp;from,
          java.lang.Object&nbsp;to,
          java.lang.Object&nbsp;info)</code>
<div class="block">Removes the given edge, then changes its from, to, and info values to the provided ones,
        then adds the edge to the network again.</div>
</td>
</tr>
</table>
<ul class="blockList">
<li class="blockList"><a name="methods_inherited_from_class_java.lang.Object">
<!--   -->
</a>
<h3>Methods inherited from class&nbsp;java.lang.Object</h3>
<code>clone, equals, finalize, getClass, hashCode, notify, notifyAll, toString, wait, wait, wait</code></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
<div class="details">
<ul class="blockList">
<li class="blockList">
<!-- ============ FIELD DETAIL =========== -->
<ul class="blockList">
<li class="blockList"><a name="field_detail">
<!--   -->
</a>
<h3>Field Detail</h3>
<a name="indexOutInHash">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>indexOutInHash</h4>
<pre>public&nbsp;java.util.Map indexOutInHash</pre>
<div class="block">Hashes Network.IndexOutIn structures by Node.  These structures
        contain the incoming edges of the Node, its outgoing edges, and the index of
        the Node in the allNodes bag.</div>
</li>
</ul>
<a name="allNodes">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>allNodes</h4>
<pre>public&nbsp;<a href="../../../sim/util/Bag.html" title="class in sim.util">Bag</a> allNodes</pre>
<div class="block">All the objects in the sparse field.  For fast scans.  Do not rely on this bag always being the same object.</div>
</li>
</ul>
<a name="ANY_SIZE">
<!--   -->
</a>
<ul class="blockListLast">
<li class="blockList">
<h4>ANY_SIZE</h4>
<pre>public static final&nbsp;int ANY_SIZE</pre>
<div class="block">Pass this into buildMap to indicate that it should make a map of any size it likes.</div>
<dl><dt><span class="strong">See Also:</span></dt><dd><a href="../../../constant-values.html#sim.field.network.Network.ANY_SIZE">Constant Field Values</a></dd></dl>
</li>
</ul>
</li>
</ul>
<!-- ========= CONSTRUCTOR DETAIL ======== -->
<ul class="blockList">
<li class="blockList"><a name="constructor_detail">
<!--   -->
</a>
<h3>Constructor Detail</h3>
<a name="Network(boolean)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>Network</h4>
<pre>public&nbsp;Network(boolean&nbsp;directed)</pre>
<div class="block">Constructs a directed or undirected graph.</div>
</li>
</ul>
<a name="Network()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>Network</h4>
<pre>public&nbsp;Network()</pre>
<div class="block">Constructs a directed graph</div>
</li>
</ul>
<a name="Network(sim.field.network.Network)">
<!--   -->
</a>
<ul class="blockListLast">
<li class="blockList">
<h4>Network</h4>
<pre>public&nbsp;Network(<a href="../../../sim/field/network/Network.html" title="class in sim.field.network">Network</a>&nbsp;other)</pre>
<div class="block">Constructs copy of an existing graph.</div>
</li>
</ul>
</li>
</ul>
<!-- ============ METHOD DETAIL ========== -->
<ul class="blockList">
<li class="blockList"><a name="method_detail">
<!--   -->
</a>
<h3>Method Detail</h3>
<a name="isDirected()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>isDirected</h4>
<pre>public&nbsp;boolean&nbsp;isDirected()</pre>
</li>
</ul>
<a name="reset(boolean)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>reset</h4>
<pre>public&nbsp;void&nbsp;reset(boolean&nbsp;directed)</pre>
<div class="block">Resets the network, clearing it of nodes and edges.</div>
</li>
</ul>
<a name="getAdjacencyList(boolean)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getAdjacencyList</h4>
<pre>public&nbsp;<a href="../../../sim/field/network/Edge.html" title="class in sim.field.network">Edge</a>[][]&nbsp;getAdjacencyList(boolean&nbsp;outEdges)</pre>
<div class="block">Creates and returns an adjacency list.  If you're doing lots of operations (especially network traversals)
        which won't effect the topology of the network, an adjacency list structure might be more efficient for you to access rather than lots of
        calls to getEdgesIn() and getEdgesOut() etc.  Building the list is an O(#edges) operation.

        <p>The adjacency list is an array of Edge arrays.  Each edge array holds all outgoing edges from a node
        (if outEdges is true -- otherwise it's the incoming edges to the node).  The edge arrays are ordered in
        their parent array in the same order that the corresponding nodes are ordered in the allNodes bag.

        <p>As soon as you modify any part of the Network's topology (through addEdge(), addNode(), removeEdge(),
        removeNode(), removeAllNodes(), etc.), the adjacency list data is invalid and should not be used.  Instead, request
        a new adjacency list. 

        <p>You can modify these edge arrays any way you like, though the Edge objects are the actual Edges
        used in the Network.  This means you can't add them to another Nework, though you can add copies
        of them (as in myNewNetwork.add(new Edge(myAdjacencyList[i][j])); )</div>
</li>
</ul>
<a name="getAdjacencyMatrix()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getAdjacencyMatrix</h4>
<pre>public&nbsp;<a href="../../../sim/field/network/Edge.html" title="class in sim.field.network">Edge</a>[][]&nbsp;getAdjacencyMatrix()</pre>
<div class="block">Creates and returns a simple adjacency matrix, where only one edge between any two nodes is considered -- if you're
        using a multigraph, use getMultigraphAdjacencyMatrix() instead.  If you're doing lots of operations (especially network traversals)
        which won't effect the topology of the network, an adjacency matrix structure might be more efficient for you to access rather than lots of
        calls to getEdgesIn() and getEdgesOut() etc.  Building the matrix is an O(#edges + #nodes^2) operation.

        <p>The adjacency matrix is a two-dimensional array of Edges, each dimension as long as the number of nodes in the graph.
        Each entry in the array is either an Edge FROM a node TO another, or it is null (if there is no such edge).  If there are multiple
        edges between any two nodes, an arbitrary one is chosen.  The Edge array returned is organized as Edge[FROM][TO].
        The indices are ordered in the same order that the corresponding nodes are ordered in the allNodes bag.

        <p>As soon as you modify any part of the Network's topology (through addEdge(), addNode(), removeEdge(),
        removeNode(), removeAllNodes(), etc.), the adjacency matrix data is invalid and should not be used.  Instead, request
        a new adjacency matrix. 

        <p>You can modify these edge arrays any way you like, though the Edge objects are the actual Edges
        used in the Network.  This means you can't add them to another Nework, though you can add copies
        of them (as in myNewNetwork.add(new Edge(myAdjacencyList[i][j])); )</div>
</li>
</ul>
<a name="getMultigraphAdjacencyMatrix()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getMultigraphAdjacencyMatrix</h4>
<pre>public&nbsp;<a href="../../../sim/field/network/Edge.html" title="class in sim.field.network">Edge</a>[][][]&nbsp;getMultigraphAdjacencyMatrix()</pre>
<div class="block">Creates and returns a multigraph adjacency matrix, which includes all edges from a given node to another -- if you know for sure
        that you have a simple graph (no multiple edges between two nodes), use getAdjacencyMatrix instead.  
        If you're doing lots of operations (especially network traversals) which won't effect the topology of the network, an 
        adjacency matrix structure might be more efficient for you to access rather than lots of calls to getEdgesIn() and 
        getEdgesOut() etc.  Building the matrix is expensive: it's an O(#edges + #nodes^2) operation.

        <p>The adjacency matrix is a two-dimensional array of Edge arrays, both of the dimensions as long as the number of nodes in the graph.
        Each entry in this two-dimensional array is an <b>array</b> of all edges FROM a node TO another.  Thus the
        returned array structure is organized as Edge[FROM][TO][EDGES].
        The FROM and TO indices are ordered in the same order that the corresponding nodes are ordered in the allNodes bag.

        <p>Important note: if there are <i>no</i> edges FROM a given node TO another, an empty array is placed in that entry.
        For efficiency's sake, the <i>same</i> empty array is used.  Thus you should not assume that you can compare edge arrays
        for equality (an unlikely event anyway). 

        <p>As soon as you modify any part of the Network's topology (through addEdge(), addNode(), removeEdge(),
        removeNode(), removeAllNodes(), etc.), the adjacency matrix data is invalid and should not be used.  Instead, request
        a new adjacency matrix. 

        <p>You can modify these edge arrays any way you like, though the Edge objects are the actual Edges
        used in the Network.  This means you can't add them to another Nework, though you can add copies
        of them (as in myNewNetwork.add(new Edge(myAdjacencyList[i][j])); )</div>
</li>
</ul>
<a name="getEdgesOut(java.lang.Object)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getEdgesOut</h4>
<pre>public&nbsp;<a href="../../../sim/util/Bag.html" title="class in sim.util">Bag</a>&nbsp;getEdgesOut(java.lang.Object&nbsp;node)</pre>
<div class="block">Get all edges that leave a node.  Do NOT modify this Bag -- it is used internally.</div>
</li>
</ul>
<a name="getEdgesIn(java.lang.Object)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getEdgesIn</h4>
<pre>public&nbsp;<a href="../../../sim/util/Bag.html" title="class in sim.util">Bag</a>&nbsp;getEdgesIn(java.lang.Object&nbsp;node)</pre>
<div class="block">Get all edges that enter a node.  Do NOT modify this Bag -- it is used internally.</div>
</li>
</ul>
<a name="getEdges(java.lang.Object, sim.util.Bag)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getEdges</h4>
<pre>public&nbsp;<a href="../../../sim/util/Bag.html" title="class in sim.util">Bag</a>&nbsp;getEdges(java.lang.Object&nbsp;node,
           <a href="../../../sim/util/Bag.html" title="class in sim.util">Bag</a>&nbsp;bag)</pre>
<div class="block">Get all the edges that enter or leave a node.  If a Bag is provided, it will be cleared, then filled and returned.
        Else a Bag will be constructed and returned.  If the graph is undirected, then edgesIn and edgesOut should
        be the same thing, and so this is roughly equivalent to bag.addAll(getEdgesIn(node));  If the graph is
        directed, then both the edgesIn AND the edgesOut are added to the Bag.  Generally speaking you should
        try to use the more efficient getEdgesIn(...) and getEdgesOut(...) methods instead if you can.</div>
</li>
</ul>
<a name="getEdge(java.lang.Object, java.lang.Object)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getEdge</h4>
<pre>public&nbsp;<a href="../../../sim/field/network/Edge.html" title="class in sim.field.network">Edge</a>&nbsp;getEdge(java.lang.Object&nbsp;from,
           java.lang.Object&nbsp;to)</pre>
<div class="block">Returns an arbitrary edge connecting the "from" node to the "to" node, if one exists, else returns null.
        If the graph is undirected, which node is "from" vs. "to" does not matter.</div>
</li>
</ul>
<a name="getEdges(java.lang.Object, java.lang.Object, sim.util.Bag)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getEdges</h4>
<pre>public&nbsp;<a href="../../../sim/util/Bag.html" title="class in sim.util">Bag</a>&nbsp;getEdges(java.lang.Object&nbsp;from,
           java.lang.Object&nbsp;to,
           <a href="../../../sim/util/Bag.html" title="class in sim.util">Bag</a>&nbsp;bag)</pre>
<div class="block">Clears the provided Bag, then places in it all edges connecting the "from" node to the "to" node. Returns the Bag.
        If null is passed in for the Bag, then a new one is created and returned.
        If the graph is undirected, which node is "from" vs. "to" does not matter.</div>
</li>
</ul>
<a name="addNode(java.lang.Object)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>addNode</h4>
<pre>public&nbsp;void&nbsp;addNode(java.lang.Object&nbsp;node)</pre>
<div class="block">Add a node</div>
</li>
</ul>
<a name="addEdge(java.lang.Object, java.lang.Object, java.lang.Object)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>addEdge</h4>
<pre>public&nbsp;void&nbsp;addEdge(java.lang.Object&nbsp;from,
           java.lang.Object&nbsp;to,
           java.lang.Object&nbsp;info)</pre>
<div class="block">Add an edge, storing info as the edge's associated information object. 
        If you add an edge, and its nodes have not been added yet, they will
        automatically be added as well.</div>
</li>
</ul>
<a name="addEdge(sim.field.network.Edge)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>addEdge</h4>
<pre>public&nbsp;void&nbsp;addEdge(<a href="../../../sim/field/network/Edge.html" title="class in sim.field.network">Edge</a>&nbsp;edge)</pre>
<div class="block">Add an edge. If you add an edge, and its nodes have not been added yet, they will
        automatically be added as well. Throws an exception if the edge is null or if it's
        already added to a Field (including this one).</div>
</li>
</ul>
<a name="updateEdge(sim.field.network.Edge, java.lang.Object, java.lang.Object, java.lang.Object)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>updateEdge</h4>
<pre>public&nbsp;<a href="../../../sim/field/network/Edge.html" title="class in sim.field.network">Edge</a>&nbsp;updateEdge(<a href="../../../sim/field/network/Edge.html" title="class in sim.field.network">Edge</a>&nbsp;edge,
              java.lang.Object&nbsp;from,
              java.lang.Object&nbsp;to,
              java.lang.Object&nbsp;info)</pre>
<div class="block">Removes the given edge, then changes its from, to, and info values to the provided ones,
        then adds the edge to the network again.  Ordinarily you wouldn't need to do this -- you can
        just remove an edge and add a new one.  But in the case that you want to reuse an edge (to track
        it in an inspector, for example), this function might be helpful given that Edge specifically
        denies you the ability to change its to and from values.</div>
</li>
</ul>
<a name="removeEdge(sim.field.network.Edge)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>removeEdge</h4>
<pre>public&nbsp;<a href="../../../sim/field/network/Edge.html" title="class in sim.field.network">Edge</a>&nbsp;removeEdge(<a href="../../../sim/field/network/Edge.html" title="class in sim.field.network">Edge</a>&nbsp;edge)</pre>
<div class="block">Removes an edge and returns it.  The edge will still retain its info, to, and from fields, so you can
        add it again with addEdge.   Returns null if the edge is null or if there is no such 
        edge added to the field.</div>
</li>
</ul>
<a name="removeAllEdges()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>removeAllEdges</h4>
<pre>public&nbsp;void&nbsp;removeAllEdges()</pre>
<div class="block">Remove all the edges in the network.</div>
</li>
</ul>
<a name="removeNode(java.lang.Object)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>removeNode</h4>
<pre>public&nbsp;java.lang.Object&nbsp;removeNode(java.lang.Object&nbsp;node)</pre>
<div class="block">Removes a node, deleting all incoming and outgoing edges from the Field as well.  Returns the node,
        or null if there is no such node in the field.</div>
</li>
</ul>
<a name="clear()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>clear</h4>
<pre>public&nbsp;<a href="../../../sim/util/Bag.html" title="class in sim.util">Bag</a>&nbsp;clear()</pre>
<div class="block">Removes all nodes, deleting all edges from the Field as well.  Returns the nodes as a Bag, which you
        are free to modify as it's no longer used internally by the Network.</div>
</li>
</ul>
<a name="removeAllNodes()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>removeAllNodes</h4>
<pre>public&nbsp;<a href="../../../sim/util/Bag.html" title="class in sim.util">Bag</a>&nbsp;removeAllNodes()</pre>
<div class="block">Synonym for clear(), here only for backward-compatibility.
        Removes all nodes, deleting all edges from the Field as well.  Returns the nodes as a Bag, which you
        are free to modify as it's no longer used internally by the Network.</div>
</li>
</ul>
<a name="getAllNodes()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getAllNodes</h4>
<pre>public&nbsp;<a href="../../../sim/util/Bag.html" title="class in sim.util">Bag</a>&nbsp;getAllNodes()</pre>
<div class="block">Returns all the objects in the Sparse Field.  Do NOT modify the bag that you receive out this method -- it
        is used internally.  If you wish in modify the Bag you receive, make a copy of the Bag first, 
        using something like <b>new Bag(<i>foo</i>.getallNodes())</b>.</div>
</li>
</ul>
<a name="iterator()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>iterator</h4>
<pre>public&nbsp;java.util.Iterator&nbsp;iterator()</pre>
<div class="block">Iterates over all objects.  
        NOT fail-fast, and remove() not supported.  Use this method only if you're
        woozy about accessing allObject.numObjs and allObject.objs directly. 

        For the fastest scan, you can do:
        <p><tt>

        for(int x=0;x&lt;field.allNodes.numObjs;x++) ... field.allNodes.objs[x] ... </tt>

        <p>... but do NOT modify the allNodes.objs array.</div>
</li>
</ul>
<a name="nodeExists(java.lang.Object)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>nodeExists</h4>
<pre>public&nbsp;boolean&nbsp;nodeExists(java.lang.Object&nbsp;node)</pre>
</li>
</ul>
<a name="getNodeIndex(java.lang.Object)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getNodeIndex</h4>
<pre>public&nbsp;int&nbsp;getNodeIndex(java.lang.Object&nbsp;node)</pre>
</li>
</ul>
<a name="reverseAllEdges()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>reverseAllEdges</h4>
<pre>public&nbsp;void&nbsp;reverseAllEdges()</pre>
<div class="block">This reverse the direction of all edges in the graph.
 It is more expensive to clone the graph than to reverse the edges in place.
 It is more than twice as fast to reverse the edges than to 
 create the dual graph. As a matter of fact getDualNetwork() took 240 time units
 while  two reverseAllEdges() calls took only 40 time units on a directed
 graph (1time unit = 1 millisecond / 10000 calls).
 
 In that case it is more advantageous to reverse the edges, 
 compute whatever stats on the dual and revert it than to allocate memory.</div>
</li>
</ul>
<a name="cloneGraph()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>cloneGraph</h4>
<pre>public&nbsp;<a href="../../../sim/field/network/Network.html" title="class in sim.field.network">Network</a>&nbsp;cloneGraph()</pre>
<div class="block"><span class="strong">Deprecated.</span>&nbsp;<i></i></div>
<div class="block">Makes a duplicate copy of the graph.</div>
</li>
</ul>
<a name="getGraphComplement(boolean)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getGraphComplement</h4>
<pre>public&nbsp;<a href="../../../sim/field/network/Network.html" title="class in sim.field.network">Network</a>&nbsp;getGraphComplement(boolean&nbsp;allowSelfLoops)</pre>
<div class="block">Complements the graph: same nodes, no edges where they were, edges where they were not.
 
 An advantage over calling addNode and addEdge n and m times, 
 is to allocate the Bags the right size the first time.</div>
</li>
</ul>
<a name="buildMap(java.util.Map)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>buildMap</h4>
<pre>public&nbsp;java.util.Map&nbsp;buildMap(java.util.Map&nbsp;other)</pre>
<div class="block">Creates a Map which is a copy of another. By default, HashMap is used.</div>
</li>
</ul>
<a name="buildMap(int)">
<!--   -->
</a>
<ul class="blockListLast">
<li class="blockList">
<h4>buildMap</h4>
<pre>public&nbsp;java.util.Map&nbsp;buildMap(int&nbsp;size)</pre>
<div class="block">Creates a map of the provided size (or any size it likes if ANY_SIZE is passed in).  By default, HashMap is used.</div>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
</div>
<!-- ========= END OF CLASS DATA ========= -->
<!-- ======= START OF BOTTOM NAVBAR ====== -->
<div class="bottomNav"><a name="navbar_bottom">
<!--   -->
</a><a href="#skip-navbar_bottom" title="Skip navigation links"></a><a name="navbar_bottom_firstrow">
<!--   -->
</a>
<ul class="navList" title="Navigation">
<li><a href="../../../overview-summary.html">Overview</a></li>
<li><a href="package-summary.html">Package</a></li>
<li class="navBarCell1Rev">Class</li>
<li><a href="package-tree.html">Tree</a></li>
<li><a href="../../../deprecated-list.html">Deprecated</a></li>
<li><a href="../../../index-all.html">Index</a></li>
<li><a href="../../../help-doc.html">Help</a></li>
</ul>
</div>
<div class="subNav">
<ul class="navList">
<li><a href="../../../sim/field/network/Edge.html" title="class in sim.field.network"><span class="strong">Prev Class</span></a></li>
<li><a href="../../../sim/field/network/Network.IndexOutIn.html" title="class in sim.field.network"><span class="strong">Next Class</span></a></li>
</ul>
<ul class="navList">
<li><a href="../../../index.html?sim/field/network/Network.html" target="_top">Frames</a></li>
<li><a href="Network.html" target="_top">No Frames</a></li>
</ul>
<ul class="navList" id="allclasses_navbar_bottom">
<li><a href="../../../allclasses-noframe.html">All Classes</a></li>
</ul>
<div>
<script type="text/javascript"><!--
  allClassesLink = document.getElementById("allclasses_navbar_bottom");
  if(window==top) {
    allClassesLink.style.display = "block";
  }
  else {
    allClassesLink.style.display = "none";
  }
  //-->
</script>
</div>
<div>
<ul class="subNavList">
<li>Summary:&nbsp;</li>
<li><a href="#nested_class_summary">Nested</a>&nbsp;|&nbsp;</li>
<li><a href="#field_summary">Field</a>&nbsp;|&nbsp;</li>
<li><a href="#constructor_summary">Constr</a>&nbsp;|&nbsp;</li>
<li><a href="#method_summary">Method</a></li>
</ul>
<ul class="subNavList">
<li>Detail:&nbsp;</li>
<li><a href="#field_detail">Field</a>&nbsp;|&nbsp;</li>
<li><a href="#constructor_detail">Constr</a>&nbsp;|&nbsp;</li>
<li><a href="#method_detail">Method</a></li>
</ul>
</div>
<a name="skip-navbar_bottom">
<!--   -->
</a></div>
<!-- ======== END OF BOTTOM NAVBAR ======= -->
</body>
</html>
